<script>
(function() {
  'use strict';
  if (!window.ArcComponents) {
    window.ArcComponents = {};
  }
  /**
   * This mixin is to reduce amount of code in `arc-request-workspace` element
   * and to separate drag and drop for tabs logic.
   *
   * @mixinFunction
   * @polymer
   * @memberof ArcComponents
   */
  window.ArcComponents.ArcWorkspaceDndMixin = Polymer.dedupingMixin((base) => {
    /**
     * @polymer
     * @mixinClass
     */
    class ArcWorkspaceDndMixin extends base {
      static get properties() {
        return {
          /**
           * Adds draggable property to the request list item element.
           * The `dataTransfer` object has `arc/request-object` mime type with
           * serialized JSON with request model.
           */
          draggableEnabled: {type: Boolean, value: false, observer: '_draggableChanged'}
        };
      }
      /**
       * @return {Boolean} True if tabs drag and drop is possible.
       */
      get _dragPossible() {
        const r = this.activeRequests;
        return !!(r && r.length > 1);
      }

      constructor() {
        super();
        this._dragoverHandler = this._dragoverHandler.bind(this);
        this._dragleaveHandler = this._dragleaveHandler.bind(this);
        this._dropHandler = this._dropHandler.bind(this);
      }

      connectedCallback() {
        super.connectedCallback();
        if (this.draggableEnabled) {
          this._addDndEvents();
        }
      }

      disconnectedCallback() {
        super.disconnectedCallback();
        this._removeDndEvents();
      }

      _draggableChanged(value) {
        if (value) {
          this._addDndEvents();
        } else {
          this._removeDndEvents();
        }
      }

      _addDndEvents() {
        if (this.__dndAdded) {
          return;
        }
        this.__dndAdded = true;
        this.$.tabs.addEventListener('dragover', this._dragoverHandler);
        this.$.tabs.addEventListener('dragleave', this._dragleaveHandler);
        this.$.tabs.addEventListener('drop', this._dropHandler);
      }

      _removeDndEvents() {
        if (!this.__dndAdded) {
          return;
        }
        this.__dndAdded = false;
        this.$.tabs.removeEventListener('dragover', this._dragoverHandler);
        this.$.tabs.removeEventListener('dragleave', this._dragleaveHandler);
        this.$.tabs.removeEventListener('drop', this._dropHandler);
      }

      /**
       * Handler for the `dragstart` event added to the list item when `draggableEnabled`
       * is set to true.
       * This function sets request data on the `dataTransfer` object with `arc/request-object`
       * mime type. The request data is a serialized JSON with request model.
       * @param {Event} e
       */
      _dragStart(e) {
        if (!this.draggableEnabled) {
          return;
        }
        const request = e.model.get('item');
        const data = JSON.stringify(request);
        e.dataTransfer.setData('arc/request-object', data);
        if (request.type === 'saved') {
          e.dataTransfer.setData('arc/saved-request', request._id);
        } else if (request.type === 'history') {
          e.dataTransfer.setData('arc/history-request', request._id);
        }
        e.dataTransfer.setData('arc-source/requests-workspace', request._id);
        e.dataTransfer.effectAllowed = 'copy';
        const target = e.currentTarget;
        Polymer.RenderStatus.afterNextRender(this, () => {
          const style = getComputedStyle(this);
          this.__tabsSelectionColor = style.getPropertyValue('--paper-tabs-selection-bar-color').trim();
          this.__tabsSelectionColor2 = style.getPropertyValue('--paper-tabs-selection-bar_-_border-color').trim();
          this.$.tabs.style.setProperty('--paper-tabs-selection-bar-color', 'transparent');
          this.$.tabs.style.setProperty('--paper-tabs-selection-bar_-_border-color', 'transparent');
          this.__tabsInitialDisplay = target.style.display;
          target.style.display = 'none';
        });
      }

      _dragEnd(e) {
        e.currentTarget.style.display = this.__tabsInitialDisplay;
        this.$.tabs.style.setProperty('--paper-tabs-selection-bar-color', this.__tabsSelectionColor);
        this.$.tabs.style.setProperty('--paper-tabs-selection-bar_-_border-color', this.__tabsSelectionColor2);
      }
      /**
       * Computes value for the `draggable` property of the list item.
       * When `draggableEnabled` is set it returns true which is one of the
       * conditions to enable drag and drop on an element.
       * @param {Boolean} draggableEnabled Current value of `draggableEnabled`
       * @return {String} `true` or `false` (as string) depending on the argument.
       */
      _computeDraggableValue(draggableEnabled) {
        return draggableEnabled ? 'true' : 'false';
      }
      /**
       * Handler for `dragover` event on this element. If the dagged item is compatible
       * it renders drop message.
       * @param {DragEvent} e
       */
      _dragoverHandler(e) {
        if (!this.draggableEnabled) {
          return;
        }
        console.log('over', e);
        if (e.dataTransfer.types.indexOf('arc/request-object') === -1) {
          return;
        }
        e.dataTransfer.dropEffect = 'copy';
        e.preventDefault();
        if (e.dataTransfer.types.indexOf('arc-source/requests-workspace') !== -1) {
          this._reorderDragover(e);
        } else {
          this._newTabDragover(e);
        }
      }

      _reorderDragover(e) {
        const dragElement = this._getReorderedItem(e);
        this._dragElement = dragElement;
        this._dragModel = e.model;
        this._blockEditors();
      }

      _newTabDragover() {

      }
      /**
       * Handler for `dragleave` event on this element. If the dagged item is compatible
       * it hides drop message.
       * @param {DragEvent} e
       */
      _dragleaveHandler(e) {
        if (!this.draggableEnabled) {
          return;
        }
        console.log('leave', e);
        if (e.dataTransfer.types.indexOf('arc/request-object') === -1) {
          return;
        }
        e.preventDefault();
        if (this.classList.contains('drop-target')) {
          this.classList.remove('drop-target');
        }
      }
      /**
       * Handler for `drag` event on this element. If the dagged item is compatible
       * it adds request to saved requests.
       * @param {DragEvent} e
       */
      _dropHandler(e) {
        if (!this.draggableEnabled) {
          return;
        }
        if (e.dataTransfer.types.indexOf('arc/request-object') === -1 ||
          e.dataTransfer.types.indexOf('arc/saved-request') !== -1) {
          return;
        }
        e.preventDefault();
        if (this.classList.contains('drop-target')) {
          this.classList.remove('drop-target');
        }
        const data = e.dataTransfer.getData('arc/request-object');
        if (!data) {
          return;
        }
        const request = JSON.parse(data);
        this._appendRequest(request);
      }
      /**
       * Handles track event dispatched by `Polymer.Gestures` library.
       * This method calls corresponding method to current dragging state.
       * @param {CustomEvent} e
       */
      _handleTrack(e) {
        if (!this._dragPossible) {
          return;
        }
        switch (e.detail.state) {
          case 'start':
            this._onTrackStart(e);
            break;
          case 'track':
            this._onTrack(e);
            break;
          case 'end':
            this._onTrackEnd(e);
            break;
        }
      }
      /**
       * Initializes the tracking of an element.
       * @param {CustomEvent} e Original event from the Gestures library.
       */
      _onTrackStart(e) {
        // this._startScrollLeft = this.scrollLeft;
        this._startScrollLeft = this.$.tabs.$.tabsContainer.scrollLeft;
        const dragElement = this._getReorderedItem(e);
        dragElement.style.pointerEvents = 'none';
        dragElement.classList.add('dragging');
        this._dragElement = dragElement;
        this._dragModel = e.model;
        this._blockEditors();
      }
      /**
       * Called when the element is being tacked (moved).
       * @param {CustomEvent} e Original event from the Gestures library.
       */
      _onTrack(e) {
        this._updateTabPosition(e.detail.ddx);
        this._updateDragPosition(e.detail.dx);
        const overEl = e.detail.hover();
        const overModel = overEl && this.$.tabsRepeater.modelForElement(overEl);
        if (!overModel) {
          return;
        }
        this._dirOffset = e.detail.ddx < 0 ? -1 : 0;
        this._overModel = overModel;
        const lastOverIndex = this._overIndex || 0;
        const overIndex = overModel.index + this._dirOffset;
        const start = Math.max(overIndex < lastOverIndex ? overIndex : lastOverIndex, 0);
        const end = overModel.index < lastOverIndex ? lastOverIndex : overModel.index;
        const draggedIndex = this._dragModel.get('index');
        const children = this.$.tabs.querySelectorAll('paper-tab');
        for (let i = start; i <= end; i++) {
          const el = children[i];
          if (i !== draggedIndex) {
            let dir = 0;
            if (i > draggedIndex && i <= overIndex) {
              dir = -1;
            } else if (i > overIndex && i < draggedIndex) {
              dir = 1;
            }
            el.classList.add('moving');
            el.style.transform =
              `translate3d(${dir * this._dragElement.offsetWidth}px, 0px, 0px)`;
          }
        }
        this._overIndex = overModel.index;
      }
      /**
       * Performs operation when the tab drop occurs.
       */
      _onTrackEnd() {
        if (!this._dragElement) {
          return;
        }
        this._dragElement.style.pointerEvents = '';
        // this._dragElement.style.transform = '';
        this._dragElement.classList.remove('dragging');
        this._dragElement = undefined;
        const movedItem = this._dragModel.get('item');
        const fromIdx = this.activeRequests.indexOf(movedItem);
        let toIdx;
        if (fromIdx >= 0 && this._overModel) {
          toIdx = this.activeRequests.indexOf(this._overModel.item) +
            (this._overModel.index > this._dragModel.get('index') ? this._dirOffset : 0);
          const item = this.splice('activeRequests', fromIdx, 1)[0];
          this.splice('activeRequests', toIdx, 0, item);
        }
        const children = this.$.tabs.querySelectorAll('paper-tab');
        for (let i = 0, len = children.length; i < len; i++) {
          children[i].style.transform = '';
          children[i].classList.remove('moving');
        }
        if (toIdx || toIdx === 0) {
          this.selected = toIdx;
        }
        this._dragModel = undefined;
        this._overModel = undefined;
        this._unblockEditors();
        this.refreshTabs();
      }
      /**
       * Sets `readonly` state on all editors
       */
      _blockEditors() {
        const nodes = this.shadowRoot.querySelectorAll('request-panel');
        for (let i = 0; i < nodes.length; i++) {
          nodes[i].readonly = true;
        }
      }
      /**
       * Removes `readonly` state from all editors
       */
      _unblockEditors() {
        Polymer.RenderStatus.flush();
        Polymer.RenderStatus.afterNextRender(this, () => {
          const nodes = this.shadowRoot.querySelectorAll('request-panel');
          for (let i = 0; i < nodes.length; i++) {
            nodes[i].readonly = false;
          }
        });
      }
      /**
       * Gets the top level item from the DOM repeater that has been marked as a
       * draggable item.
       * The event can originate from child elements which shouldn't be dragged.
       *
       * @param {Event} e The track event
       * @return {HTMLElement} An element that is container for draggable items. Undefined if couldn't
       * find.
       */
      _getReorderedItem(e) {
        const elmName = 'PAPER-TAB';
        if (e.target.nodeName === elmName) {
          return e.target;
        }
        const path = e.composedPath();
        if (!path || !path.length) {
          return;
        }
        for (let i = 0, len = path.length; i < len; i++) {
          const node = path[i];
          if (node.nodeName === elmName) {
            return path[i];
          }
        }
      }
      /**
       * Re-positions dragged element to the place where it belongs.
       * It accounts for scroll position if it changed since dragging started.
       * @param {Number} dx Delta X from starting position.
       */
      _updateDragPosition(dx) {
        this._trackDelta = dx || this._trackDelta || 0;
        // const scrollDelta = this.scrollLeft - this._startScrollLeft;
        const scrollDelta = this.$.tabs.$.tabsContainer.scrollLeft - this._startScrollLeft;
        const pos = this._trackDelta + scrollDelta;
        this._dragElement.style.transform = `translate3d(${pos}px,0,0)`;
      }
      /**
       * Scrolls tabs right or left depending on dragged element position.
       * @param {Number} ddx delta from last tracked position
       */
      _updateTabPosition(ddx) {
        const tabsRect = this.$.tabs.$.tabsContainer.getBoundingClientRect();
        const tabRect = this._dragElement.getBoundingClientRect();
        if (ddx > 0) {
          const mostRigth = tabsRect.x + tabsRect.width;
          const tabMostRight = tabRect.x + tabRect.width;
          if (tabMostRight > mostRigth) {
            this.$.tabs._affectScroll(ddx * 5);
          }
        } else if (ddx < 0) {
          if (tabRect.x < tabsRect.x) {
            this.$.tabs._affectScroll(ddx * 5);
          }
        }
      }
    }
    return ArcWorkspaceDndMixin;
  });
})();
</script>
