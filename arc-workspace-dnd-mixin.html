<script>
(function() {
  'use strict';
  if (!window.ArcComponents) {
    window.ArcComponents = {};
  }
  /**
   * This mixin is to reduce amount of code in `arc-request-workspace` element
   * and to separate drag and drop for tabs logic.
   *
   * @mixinFunction
   * @polymer
   * @memberof ArcComponents
   */
  window.ArcComponents.ArcWorkspaceDndMixin = Polymer.dedupingMixin((base) => {
    /**
     * @polymer
     * @mixinClass
     */
    class ArcWorkspaceDndMixin extends base {
      /**
       * @return {Boolean} True if tabs drag and drop is possible.
       */
      get _dragPossible() {
        const r = this.activeRequests;
        return !!(r && r.length > 1);
      }
      /**
       * Handles track event dispatched by `Polymer.Gestures` library.
       * This method calls corresponding method to current dragging state.
       * @param {CustomEvent} e
       */
      _handleTrack(e) {
        if (!this._dragPossible) {
          return;
        }
        switch (e.detail.state) {
          case 'start':
            this._onTrackStart(e);
            break;
          case 'track':
            this._onTrack(e);
            break;
          case 'end':
            this._onTrackEnd(e);
            break;
        }
      }
      /**
       * Initializes the tracking of an element.
       * @param {CustomEvent} e Original event from the Gestures library.
       */
      _onTrackStart(e) {
        // this._startScrollLeft = this.scrollLeft;
        this._startScrollLeft = this.$.tabs.$.tabsContainer.scrollLeft;
        const dragElement = this._getReorderedItem(e);
        dragElement.style.pointerEvents = 'none';
        dragElement.classList.add('dragging');
        this._dragElement = dragElement;
        this._dragModel = e.model;
        this._blockEditors();
      }
      /**
       * Called when the element is being tacked (moved).
       * @param {CustomEvent} e Original event from the Gestures library.
       */
      _onTrack(e) {
        this._updateTabPosition(e.detail.ddx);
        this._updateDragPosition(e.detail.dx);
        const overEl = e.detail.hover();
        const overModel = overEl && this.$.tabsRepeater.modelForElement(overEl);
        if (!overModel) {
          return;
        }
        this._dirOffset = e.detail.ddx < 0 ? -1 : 0;
        this._overModel = overModel;
        const lastOverIndex = this._overIndex || 0;
        const overIndex = overModel.index + this._dirOffset;
        const start = Math.max(overIndex < lastOverIndex ? overIndex : lastOverIndex, 0);
        const end = overModel.index < lastOverIndex ? lastOverIndex : overModel.index;
        const draggedIndex = this._dragModel.get('index');
        const children = this.$.tabs.querySelectorAll('paper-tab');
        for (let i = start; i <= end; i++) {
          const el = children[i];
          if (i !== draggedIndex) {
            let dir = 0;
            if (i > draggedIndex && i <= overIndex) {
              dir = -1;
            } else if (i > overIndex && i < draggedIndex) {
              dir = 1;
            }
            el.classList.add('moving');
            el.style.transform =
              `translate3d(${dir * this._dragElement.offsetWidth}px, 0px, 0px)`;
          }
        }
        this._overIndex = overModel.index;
      }
      /**
       * Performs operation when the tab drop occurs.
       */
      _onTrackEnd() {
        if (!this._dragElement) {
          return;
        }
        this._dragElement.style.pointerEvents = '';
        // this._dragElement.style.transform = '';
        this._dragElement.classList.remove('dragging');
        this._dragElement = undefined;
        const movedItem = this._dragModel.get('item');
        const fromIdx = this.activeRequests.indexOf(movedItem);
        let toIdx;
        if (fromIdx >= 0 && this._overModel) {
          toIdx = this.activeRequests.indexOf(this._overModel.item) +
            (this._overModel.index > this._dragModel.get('index') ? this._dirOffset : 0);
          const item = this.splice('activeRequests', fromIdx, 1)[0];
          this.splice('activeRequests', toIdx, 0, item);
        }
        const children = this.$.tabs.querySelectorAll('paper-tab');
        for (let i = 0, len = children.length; i < len; i++) {
          children[i].style.transform = '';
          children[i].classList.remove('moving');
        }
        if (toIdx || toIdx === 0) {
          this.selected = toIdx;
        }
        this._dragModel = undefined;
        this._overModel = undefined;
        this._unblockEditors();
        this.refreshTabs();
      }
      /**
       * Sets `readonly` state on all editors
       */
      _blockEditors() {
        const nodes = this.shadowRoot.querySelectorAll('request-panel');
        for (let i = 0; i < nodes.length; i++) {
          nodes[i].readonly = true;
        }
      }
      /**
       * Removes `readonly` state from all editors
       */
      _unblockEditors() {
        Polymer.RenderStatus.flush();
        Polymer.RenderStatus.afterNextRender(this, () => {
          const nodes = this.shadowRoot.querySelectorAll('request-panel');
          for (let i = 0; i < nodes.length; i++) {
            nodes[i].readonly = false;
          }
        });
      }
      /**
       * Gets the top level item from the DOM repeater that has been marked as a
       * draggable item.
       * The event can originate from child elements which shouldn't be dragged.
       *
       * @param {Event} e The track event
       * @return {HTMLElement} An element that is container for draggable items. Undefined if couldn't
       * find.
       */
      _getReorderedItem(e) {
        const elmName = 'PAPER-TAB';
        if (e.target.nodeName === elmName) {
          return e.target;
        }
        const path = e.composedPath();
        if (!path || !path.length) {
          return;
        }
        for (let i = 0, len = path.length; i < len; i++) {
          const node = path[i];
          if (node.nodeName === elmName) {
            return path[i];
          }
        }
      }
      /**
       * Re-positions dragged element to the place where it belongs.
       * It accounts for scroll position if it changed since dragging started.
       * @param {Number} dx Delta X from starting position.
       */
      _updateDragPosition(dx) {
        this._trackDelta = dx || this._trackDelta || 0;
        // const scrollDelta = this.scrollLeft - this._startScrollLeft;
        const scrollDelta = this.$.tabs.$.tabsContainer.scrollLeft - this._startScrollLeft;
        const pos = this._trackDelta + scrollDelta;
        this._dragElement.style.transform = `translate3d(${pos}px,0,0)`;
      }
      /**
       * Scrolls tabs right or left depending on dragged element position.
       * @param {Number} ddx delta from last tracked position
       */
      _updateTabPosition(ddx) {
        const tabsRect = this.$.tabs.$.tabsContainer.getBoundingClientRect();
        const tabRect = this._dragElement.getBoundingClientRect();
        if (ddx > 0) {
          const mostRigth = tabsRect.x + tabsRect.width;
          const tabMostRight = tabRect.x + tabRect.width;
          if (tabMostRight > mostRigth) {
            this.$.tabs._affectScroll(ddx * 5);
          }
        } else if (ddx < 0) {
          if (tabRect.x < tabsRect.x) {
            this.$.tabs._affectScroll(ddx * 5);
          }
        }
      }
    }
    return ArcWorkspaceDndMixin;
  });
})();
</script>
