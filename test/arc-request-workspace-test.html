<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>arc-request-workspace test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <!-- CodeMirror + modes loader -->
  <script src="../../../codemirror/lib/codemirror.js"></script>
  <script src="../../../codemirror/addon/mode/loadmode.js"></script>
  <script src="../../../codemirror/mode/meta.js"></script>
  <!--Default set of parsers, add as many as you need -->
  <script src="../../../codemirror/mode/javascript/javascript.js"></script>
  <script src="../../../codemirror/mode/xml/xml.js"></script>
  <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <!-- JSON linter -->
  <script src="../../../jsonlint/lib/jsonlint.js"></script>
  <script src="../../../codemirror/addon/lint/lint.js"></script>
  <script src="../../../codemirror/addon/lint/json-lint.js"></script>
  <!-- Headers hint support -->
  <script src="../../../@advanced-rest-client/code-mirror-hint/headers-addon.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/show-hint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/hint-http-headers.js"></script>

</head>
<body>
  <project-model></project-model>
  <request-model></request-model>
  <variables-model></variables-model>

  <test-fixture id="Basic">
    <template>
      <arc-request-workspace no-auto-projects></arc-request-workspace>
    </template>
  </test-fixture>

  <test-fixture id="NoAuto">
    <template>
      <arc-request-workspace no-auto-projects no-auto-restore></arc-request-workspace>
    </template>
  </test-fixture>

  <script type="module">
  import '../arc-request-workspace.js';
  import {DataGenerator} from '../../arc-data-generator/arc-data-generator.js';
  import * as MockInteractions from '../../../@polymer/iron-test-helpers/mock-interactions.js';
  import {afterNextRender} from '../../../@polymer/polymer/lib/utils/render-status.js';
  import '../../arc-models/project-model.js';
  import '../../arc-models/request-model.js';
  import '../../arc-models/variables-model.js';
  import sinon from '../../../sinon/pkg/sinon-esm.js';

  function wrapStateReadEvent(element) {
    element.addEventListener('workspace-state-read', function f(e) {
      element.removeEventListener('workspace-state-read', f);
      e.preventDefault();
      e.detail.result = Promise.resolve({});
    });
  }

  function addRequests(element, size) {
    const requests = DataGenerator.generateRequests({
      requestsSize: size || 2
    });
    for (let i = 0; i < requests.length; i++) {
      requests[i].name = 'Test request name #' + i;
      element.__addPanel(requests[i]);
    }
    element.activeRequests = requests;
  }

  suite('Basics', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      wrapStateReadEvent(element);
    });

    test('selected is eventually set', (done) => {
      element.addEventListener('selected-changed', function f() {
        element.removeEventListener('selected-changed', f);
        done();
      });
    });

    test('activeRequests has default value', () => {
      assert.typeOf(element.activeRequests, 'array');
      assert.lengthOf(element.activeRequests, 0);
    });

    test('restoring is false when initializing', () => {
      assert.isFalse(element.restoring);
    });
  });

  suite('_dispatch()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });
    const eName = 'test-event';
    const eDetail = 'test-detail';
    test('Dispatches an event', () => {
      const spy = sinon.spy();
      element.addEventListener(eName, spy);
      element._dispatch(eName);
      assert.isTrue(spy.called);
    });
    test('Returns the event', () => {
      const e = element._dispatch(eName);
      assert.typeOf(e, 'customevent');
    });
    test('Event is cancelable by default', () => {
      const e = element._dispatch(eName);
      assert.isTrue(e.cancelable);
    });
    test('Event is composed', () => {
      const e = element._dispatch(eName);
      if (typeof e.composed !== 'undefined') {
        assert.isTrue(e.composed);
      }
    });
    test('Event bubbles', () => {
      const e = element._dispatch(eName);
      assert.isTrue(e.bubbles);
    });
    test('Event is not cancelable when set', () => {
      const e = element._dispatch(eName, eDetail, false);
      assert.isFalse(e.cancelable);
    });
    test('Event has detail', () => {
      const e = element._dispatch(eName, eDetail);
      assert.equal(e.detail, eDetail);
    });
  });

  suite('_computeTabName()', () => {
    function restoreHandler(e) {
      e.preventDefault();
      e.detail.result = new Promise((resolve) => {
        const saved = DataGenerator.generateSavedRequestData({
          requestsSize: 3
        });
        const history = DataGenerator.generateHistoryRequestsData({
          requestsSize: 3
        });
        const requests = history.concat(saved.requests);
        const result = {
          selected: 1,
          environment: 'test-env',
          requests
        };
        resolve(result);
      });
    }
    let element;
    setup(() => {
      window.addEventListener('workspace-state-read', restoreHandler);
      element = fixture('Basic');
    });

    teardown(() => {
      window.removeEventListener('workspace-state-read', restoreHandler);
    });

    test('Returns "New request" for undefined item', () => {
      const result = element._computeTabName();
      assert.equal(result, 'New request');
    });

    test('Returns item name if exists', () => {
      const result = element._computeTabName('test-name');
      assert.equal(result, 'test-name');
    });

    test('Returns URL if item name does not exists', () => {
      const result = element._computeTabName(undefined, 'test-url');
      assert.equal(result, 'test-url');
    });

    test('Returns "New request" otherwise', () => {
      const result = element._computeTabName('', '');
      assert.equal(result, 'New request');
    });
  });

  suite('appendRequest()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    test('Adds empty request to the list of active requests', () => {
      element.appendRequest({method: 'x-test'});
      assert.lengthOf(element.activeRequests, 1);
    });

    test('Added request has an id', () => {
      element.appendRequest({method: 'x-test'});
      assert.typeOf(element.activeRequests[0]._id, 'string');
    });

    test('Eventually sets request data', () => {
      element.appendRequest({method: 'x-test'});
      assert.equal(element.activeRequests[0].method, 'x-test');
    });

    test('Selects newly added request', () => {
      element.appendRequest({});
      assert.equal(element.selected, 0);
    });

    test('Returns index of created request', () => {
      const result = element.appendRequest({});
      assert.equal(result, 0);
    });

    test('Won\'t set ID if already exists', () => {
      const request = {
        _id: 'test-id',
        url: 'http:api.domain.com'
      };
      element.appendRequest(request);
      assert.deepEqual(element.activeRequests[0], request);
    });

    test('Won\'t add second empty request', () => {
      element.appendRequest({});
      element.appendRequest({});
      assert.lengthOf(element.activeRequests, 1);
    });

    test('Adds two empty requests when skipPositionCheck is set', () => {
      element.appendRequest({});
      element.appendRequest({}, {skipPositionCheck: true});
      assert.lengthOf(element.activeRequests, 2);
    });

    test('Won\'t select added request when noAutoSelect is set', () => {
      element.appendRequest({});
      element.appendRequest({}, {noAutoSelect: true});
      assert.equal(element.selected, 0);
    });
  });

  suite('addEmptyRequest()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    test('Adds request to the list of active requests', () => {
      element.addEmptyRequest();
      assert.lengthOf(element.activeRequests, 1);
      const r = element.activeRequests[0];
      assert.equal(r.method, 'GET');
      assert.equal(r.url, 'http://');
    });

    test('Selects newly added request', () => {
      element.addEmptyRequest();
      assert.equal(element.selected, 0);
    });
  });

  suite('updateRequestObject()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element);
      flush(() => done());
    });

    test('Adds _id to the request', () => {
      const request = DataGenerator.generateSavedItem();
      delete request._id;
      element.updateRequestObject(request, 0);
      assert.typeOf(request._id, 'string');
    });

    test('Calls __updatePanelRequest()', () => {
      const spy = sinon.spy(element, '__updatePanelRequest');
      const request = DataGenerator.generateSavedItem();
      element.updateRequestObject(request, 1);
      assert.isTrue(spy.called);
    });

    test('Updates panel id', () => {
      const request = DataGenerator.generateSavedItem();
      element.updateRequestObject(request, 0);
      const node = element.shadowRoot.querySelector(`request-panel[data-id="${request._id}"]`);
      assert.ok(node);
    });

    test('Sets active request', () => {
      const request = DataGenerator.generateSavedItem();
      element.updateRequestObject(request, 0);
      assert.deepEqual(element.activeRequests[0], request);
    });

    test('Does nothing when no active request for the index', () => {
      const spy = sinon.spy(element, '__updatePanelRequest');
      const request = DataGenerator.generateSavedItem();
      element.updateRequestObject(request, 10);
      assert.isFalse(spy.called);
    });
  });

  suite('_closeRequest()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element);
      flush(() => done());
    });

    test('Closes request after button click', () => {
      const spy = sinon.spy(element, 'removeRequest');
      const button = element.shadowRoot.querySelectorAll('.close-icon')[1];
      MockInteractions.tap(button);
      assert.isTrue(spy.called);
    });

    test('Closes second request', () => {
      const spy = sinon.spy(element, 'removeRequest');
      const button = element.shadowRoot.querySelectorAll('.close-icon')[1];
      MockInteractions.tap(button);
      assert.equal(spy.args[0][0], 1);
    });

    test('Does nothing when event target has no data-index', () => {
      const spy = sinon.spy(element, 'removeRequest');
      const button = element.shadowRoot.querySelectorAll('.close-icon')[1];
      button.removeAttribute('data-index');
      MockInteractions.tap(button);
      assert.isFalse(spy.called);
    });
  });

  suite('removeRequest()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element);
      flush(() => done());
    });

    test('Removes request from activeRequests', () => {
      element.removeRequest(0);
      assert.lengthOf(element.activeRequests, 1);
    });

    test('Removes request at the index', () => {
      const idB = element.activeRequests[1]._id;
      element.removeRequest(0);
      assert.equal(element.activeRequests[0]._id, idB);
    });

    test('Calls __removePanel()', () => {
      const id = element.activeRequests[0]._id;
      const spy = sinon.spy(element, '__removePanel');
      element.removeRequest(0);
      assert.isTrue(spy.called);
      assert.equal(spy.args[0][0], id);
    });

    test('Removes the panel', () => {
      const id = element.activeRequests[0]._id;
      element.removeRequest(0);
      const node = element.shadowRoot.querySelector(`request-panel[data-id="${id}"]`);
      assert.notOk(node);
    });

    test('re-sets the selection when first request which is selected', () => {
      const spy = sinon.spy();
      element.selected = 0;
      element.addEventListener('selected-changed', spy);
      element.removeRequest(0);
      assert.equal(spy.callCount, 2);
      assert.equal(spy.args[0][0].detail.value, undefined);
      assert.equal(spy.args[1][0].detail.value, 0);
    });

    test('Cheges selection if higher than index', () => {
      element.selected = 1;
      element.removeRequest(0);
      assert.equal(element.selected, 0);
    });

    test('Adds empty request when no more requests', (done) => {
      element.selected = 0;
      element.removeRequest(0);
      const spy = sinon.spy(element, 'addEmptyRequest');
      element.removeRequest(0);
      afterNextRender(element, () => {
        assert.isTrue(spy.called);
        done();
      });
    });
  });

  suite('refreshTabs()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    test('Calls notifyResize() on tabs', () => {
      const node = element.shadowRoot.querySelector('paper-tabs');
      const spy = sinon.spy(node, 'notifyResize');
      element.refreshTabs();
      assert.isTrue(spy.called);
    });
  });

  suite('_dispatchExportData()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      wrapStateReadEvent(element);
    });

    test('Dispatches "export-data" event', () => {
      const spy = sinon.spy();
      element.addEventListener('export-data', spy);
      element._dispatchExportData();
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const result = element._dispatchExportData();
      assert.typeOf(result, 'customevent');
    });

    test('Event is cancelable', () => {
      const result = element._dispatchExportData();
      assert.isTrue(result.cancelable);
    });

    test('Event is composed', () => {
      const result = element._dispatchExportData();
      if (typeof result.composed !== undefined) {
        assert.isTrue(result.composed);
      }
    });

    test('Event bubbles', () => {
      const result = element._dispatchExportData();
      assert.isTrue(result.bubbles);
    });

    test('Event has detail object', () => {
      const result = element._dispatchExportData();
      assert.typeOf(result.detail, 'object');
    });

    test('Detail has type', () => {
      const result = element._dispatchExportData();
      assert.equal(result.detail.type, 'arc-export');
    });

    test('Detail has destination', () => {
      const result = element._dispatchExportData('test');
      assert.equal(result.detail.destination, 'test');
    });

    test('Detail has file', () => {
      const result = element._dispatchExportData();
      assert.equal(result.detail.file, 'arc-saved-export.json');
    });

    test('Detail has kind', () => {
      const result = element._dispatchExportData();
      assert.equal(result.detail.kind, 'ARC#SavedExport');
    });

    test('Detail has data with "requests"', () => {
      const result = element._dispatchExportData('test', true);
      assert.typeOf(result.detail.data, 'object');
      assert.isTrue(result.detail.data.requests);
    });
  });

  suite('_exportRequest()', () => {
    let element;
    let request;
    setup(() => {
      element = fixture('NoAuto');
      request = DataGenerator.generateSavedItem();
    });

    test('Dispatches export event', () => {
      element.addEventListener('export-data', function f(e) {
        element.removeEventListener('export-data', f);
        e.preventDefault();
        e.detail.result = Promise.resolve();
      });
      const spy = sinon.spy();
      element.addEventListener('export-data', spy);
      element._exportRequest(request, 'file');
      assert.isTrue(spy.called);
    });

    test('Opens error toast when export not found', (done) => {
      flush(() => {
        element._exportRequest(request, 'file');
        const toast = element.shadowRoot.querySelector('#noExport');
        assert.isTrue(toast.opened);
        done();
      });
    });

    test('Opens drive confirmation toast', (done) => {
      element.addEventListener('export-data', function f(e) {
        element.removeEventListener('export-data', f);
        e.preventDefault();
        e.detail.result = Promise.resolve();
      });
      element._exportRequest(request, 'drive');
      flush(() => {
        const toast = element.shadowRoot.querySelector('#driveSaved');
        assert.isTrue(toast.opened);
        done();
      });
    });
  });

  suite('_variablesChanged()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      element.variables = [{variable: 'test'}];
    });

    test('Does nothing when restoring workspace', () => {
      element._setRestoring(true);
      const spy = sinon.spy(element, '_notifyStoreWorkspace');
      element.set('variables.0.value', 'value');
      assert.isFalse(spy.called);
    });

    test('Calls _notifyStoreWorkspace() when variable change', () => {
      const spy = sinon.spy(element, '_notifyStoreWorkspace');
      element.set('variables.0.value', 'value');
      assert.equal(spy.callCount, 1);
    });

    test('Calls _notifyStoreWorkspace() once when adding variable', () => {
      const spy = sinon.spy(element, '_notifyStoreWorkspace');
      element.push('variables', {variable: 'other'});
      assert.equal(spy.callCount, 1);
    });

    test('Calls _notifyStoreWorkspace() once when removing variable', () => {
      const spy = sinon.spy(element, '_notifyStoreWorkspace');
      element.splice('variables', 0, 1);
      assert.equal(spy.callCount, 1);
    });
  });

  suite('_sendRequestHandler()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    function fire(element, config) {
      const detail = {
        id: 'test-id',
        url: 'http://api.domain.com'
      };
      if (config) {
        detail.config = config;
      }
      const e = new CustomEvent('api-request', {
        detail
      });
      element.dispatchEvent(e);
      return e;
    }

    test('Won\'t create a config object when no properties to add', () => {
      const e = fire(element);
      assert.isUndefined(e.detail.config);
    });

    test('Creates the config object', () => {
      element.followRedirects = true;
      const e = fire(element);
      assert.typeOf(e.detail.config, 'object');
    });

    test('Sets timeout', () => {
      element.requestTimeout = 0;
      const e = fire(element);
      assert.equal(e.detail.config.timeout, 0);
    });

    test('Will not set timeout when it is already set', () => {
      element.requestTimeout = 10;
      const e = fire(element, {timeout: 5});
      assert.equal(e.detail.config.timeout, 5);
    });

    test('Sets sentMessageLimit', () => {
      element.sentMessageLimit = 0;
      const e = fire(element);
      assert.equal(e.detail.config.sentMessageLimit, 0);
    });

    test('Will not set sentMessageLimit when it is already set', () => {
      element.sentMessageLimit = 10;
      const e = fire(element, {sentMessageLimit: 5});
      assert.equal(e.detail.config.sentMessageLimit, 5);
    });

    [
      'followRedirects', 'validateCertificates', 'variablesDisabled',
      'nativeTransport'
    ].forEach((prop) => {
      test(`Sets ${prop} when false`, () => {
        element[prop] = false;
        const e = fire(element);
        assert.isFalse(e.detail.config[prop]);
      });

      test(`Sets ${prop} when true`, () => {
        element[prop] = true;
        const e = fire(element);
        assert.isTrue(e.detail.config[prop]);
      });

      test(`Will not set ${prop} when it is already set`, () => {
        element[prop] = true;
        const config = {};
        config[prop] = false;
        const e = fire(element, config);
        assert.isFalse(e.detail.config[prop]);
      });
    });

    test('Sets variables', () => {
      element.variables = [{variable: 'test'}];
      const e = fire(element);
      assert.deepEqual(e.detail.config.variables, element.variables);
    });

    test('Variables is a copy', () => {
      element.variables = [{variable: 'test'}];
      const e = fire(element);
      e.detail.config.variables.push({variable: 'a'});
      e.detail.config.variables[0].variable = 'other';
      assert.lengthOf(element.variables, 1, 'Array is a copy');
      assert.equal(element.variables[0].variable, 'test', 'Item is a copy');
    });

    test('Will not set variables if already set', () => {
      element.variables = [{variable: 'test'}];
      const cnf = {
        variables: [{variable: 'other'}]
      };
      const e = fire(element, cnf);
      assert.deepEqual(e.detail.config.variables, cnf.variables);
    });
  });

  suite('_envChangedHandler()', () => {
    let element;
    const env = 'test-env';
    setup(() => {
      element = fixture('NoAuto');
    });

    function fire(node) {
      const e = new CustomEvent('selected-environment-changed', {
        bubbles: true,
        composed: true,
        detail: {
          value: env
        }
      });
      (node || document.body).dispatchEvent(e);
      return e;
    }

    test('Does nothing when restoring', () => {
      element._setRestoring(true);
      fire();
      assert.isUndefined(element.environment);
    });

    test('Does nothing when dispatched by self', () => {
      fire(element);
      assert.isUndefined(element.environment);
    });

    test('Sets the environment', () => {
      fire();
      assert.equal(element.environment, env);
    });
  });

  suite('findRequestIndex()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element);
    });

    test('Returns -1 when no arguments', () => {
      const result = element.findRequestIndex();
      assert.equal(result, -1);
    });

    test('Returns -1 when cannot find request', () => {
      const result = element.findRequestIndex('not-existing');
      assert.equal(result, -1);
    });

    test('Returns index of the request', () => {
      const result = element.findRequestIndex(element.activeRequests[1]._id);
      assert.equal(result, 1);
    });

    test('Returns index of the request by _tempId', () => {
      element.activeRequests[0]._tempId = 'some';
      const result = element.findRequestIndex(undefined, 'some');
      assert.equal(result, 0);
    });
  });

  suite('_getMenuRequest()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    test('Returns request object', (done) => {
      addRequests(element, 1);
      flush(() => {
        const node = element.shadowRoot.querySelector('request-panel .save-icon');
        const result = element._getMenuRequest({
          target: node
        });
        assert.typeOf(result, 'object');
        done();
      });
    });

    test('Returns undefined when request ID cannot be find', () => {
      const parent = document.createElement('div');
      const target = document.createElement('span');
      parent.appendChild(target);
      const result = element._getMenuRequest({
        target
      });
      assert.isUndefined(result);
    });

    test('Returns undefined when request does not exist', () => {
      const parent = document.createElement('div');
      const target = document.createElement('span');
      parent.dataset.id = 'other-id';
      parent.appendChild(target);
      const result = element._getMenuRequest({
        target
      });
      assert.isUndefined(result);
    });
  });

  suite('_requestStoreHandler()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    test('Calls _openSaveDialog()', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-icon');
      assert.typeOf(node.parentElement.dataset.id, 'string', 'Parent has data-id');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(element, '_openSaveDialog');
      element._requestStoreHandler(e);
      assert.isTrue(spy.called);
    });

    test('Cancels the event', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'preventDefault');
      element._requestStoreHandler(e);
      assert.isTrue(spy.called);
    });

    test('Stops event propagation', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'stopPropagation');
      element._requestStoreHandler(e);
      assert.isTrue(spy.called);
    });

    test('Does nothing when request is not found', () => {
      const node = element.shadowRoot.querySelector('request-panel');
      assert.isUndefined(node.parentElement.dataset.id);
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(element, '_openSaveDialog');
      element._requestStoreHandler(e);
      assert.isFalse(spy.called);
    });
  });

  suite('_renderRequestDetail()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    test('Sets detailsOpened to true', () => {
      const node = element.shadowRoot.querySelector('request-panel .details-icon');
      assert.typeOf(node.parentElement.dataset.id, 'string', 'Parent has data-id');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      element._renderRequestDetail(e);
      assert.isTrue(element.detailsOpened);
    });

    test('Sets request data on the panel', () => {
      const node = element.shadowRoot.querySelector('request-panel .details-icon');
      assert.typeOf(node.parentElement.dataset.id, 'string', 'Parent has data-id');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      element._renderRequestDetail(e);
      assert.typeOf(element.$.requestDetails.request, 'object');
    });

    test('Cancels the event', () => {
      const node = element.shadowRoot.querySelector('request-panel .details-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'preventDefault');
      element._renderRequestDetail(e);
      assert.isTrue(spy.called);
    });

    test('Stops event propagation', () => {
      const node = element.shadowRoot.querySelector('request-panel .details-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'stopPropagation');
      element._renderRequestDetail(e);
      assert.isTrue(spy.called);
    });

    test('Does nothing when request is not found', () => {
      const node = element.shadowRoot.querySelector('request-panel');
      assert.isUndefined(node.parentElement.dataset.id);
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      element._renderRequestDetail(e);
      assert.isFalse(element.detailsOpened);
    });
  });

  suite('_renderCodeSnippets()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    test('Sets snippetsOpened to true', () => {
      const node = element.shadowRoot.querySelector('request-panel .code-icon');
      assert.typeOf(node.parentElement.dataset.id, 'string', 'Parent has data-id');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      element._renderCodeSnippets(e);
      assert.isTrue(element.snippetsOpened);
    });

    test('Sets snippetRequest property', () => {
      const node = element.shadowRoot.querySelector('request-panel .code-icon');
      assert.typeOf(node.parentElement.dataset.id, 'string', 'Parent has data-id');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      element._renderCodeSnippets(e);
      assert.typeOf(element.snippetRequest, 'object');
    });

    test('Cancels the event', () => {
      const node = element.shadowRoot.querySelector('request-panel .code-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'preventDefault');
      element._renderCodeSnippets(e);
      assert.isTrue(spy.called);
    });

    test('Stops event propagation', () => {
      const node = element.shadowRoot.querySelector('request-panel .code-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'stopPropagation');
      element._renderCodeSnippets(e);
      assert.isTrue(spy.called);
    });

    test('Does nothing when request is not found', () => {
      const node = element.shadowRoot.querySelector('request-panel');
      assert.isUndefined(node.parentElement.dataset.id);
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      element._renderCodeSnippets(e);
      assert.isFalse(element.snippetsOpened);
    });
  });

  suite('_requestStoreFileHandler()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    test('Calls _exportRequest() with arguments', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-file-icon');
      assert.typeOf(node.parentElement.dataset.id, 'string', 'Parent has data-id');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(element, '_exportRequest');
      element._requestStoreFileHandler(e);
      assert.isTrue(spy.called);
      assert.deepEqual(spy.args[0][0], element.activeRequests[0]);
      assert.equal(spy.args[0][1], 'file');
    });

    test('Cancels the event', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-file-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'preventDefault');
      element._requestStoreFileHandler(e);
      assert.isTrue(spy.called);
    });

    test('Stops event propagation', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-file-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'stopPropagation');
      element._requestStoreFileHandler(e);
      assert.isTrue(spy.called);
    });

    test('Does nothing when request is not found', () => {
      const node = element.shadowRoot.querySelector('request-panel');
      assert.isUndefined(node.parentElement.dataset.id);
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(element, '_exportRequest');
      element._requestStoreFileHandler(e);
      assert.isFalse(spy.called);
    });
  });

  suite('_requestStoreDriveHandler()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    test('Calls _exportRequest() with arguments', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-drive-icon');
      assert.typeOf(node.parentElement.dataset.id, 'string', 'Parent has data-id');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(element, '_exportRequest');
      element._requestStoreDriveHandler(e);
      assert.isTrue(spy.called);
      assert.deepEqual(spy.args[0][0], element.activeRequests[0]);
      assert.equal(spy.args[0][1], 'drive');
    });

    test('Cancels the event', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-drive-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'preventDefault');
      element._requestStoreDriveHandler(e);
      assert.isTrue(spy.called);
    });

    test('Stops event propagation', () => {
      const node = element.shadowRoot.querySelector('request-panel .save-drive-icon');
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(e, 'stopPropagation');
      element._requestStoreDriveHandler(e);
      assert.isTrue(spy.called);
    });

    test('Does nothing when request is not found', () => {
      const node = element.shadowRoot.querySelector('request-panel');
      assert.isUndefined(node.parentElement.dataset.id);
      const e = {
        preventDefault: () => {},
        stopPropagation: () => {},
        target: node
      };
      const spy = sinon.spy(element, '_exportRequest');
      element._requestStoreDriveHandler(e);
      assert.isFalse(spy.called);
    });
  });

  suite('_requestChangeHandler()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    function fire(request, cancelable) {
      const e = new CustomEvent('request-object-changed', {
        bubbles: true,
        cancelable,
        detail: {
          request
        }
      });
      document.body.dispatchEvent(e);
      return e;
    }

    test('Updates the request', () => {
      const copy = Object.assign({}, element.activeRequests[0]);
      copy.name = 'other-name';
      fire(copy);
      assert.equal(element.activeRequests[0].name, 'other-name');
    });

    test('Updates request by tempId', () => {
      element.activeRequests[0]._tempId = 'tmp';
      const copy = Object.assign({}, element.activeRequests[0]);
      copy.name = 'other-name';
      copy._id = 'other-id';
      fire(copy);
      assert.equal(element.activeRequests[0].name, 'other-name');
    });

    test('Does nothing when request is unknown', () => {
      const request = DataGenerator.generateSavedItem();
      const old = Object.assign({}, element.activeRequests[0]);
      fire(request);
      assert.deepEqual(element.activeRequests[0], old);
    });

    test('Does nothing when event is cancelable', () => {
      const request = DataGenerator.generateSavedItem();
      const old = Object.assign({}, element.activeRequests[0]);
      fire(request, true);
      assert.deepEqual(element.activeRequests[0], old);
    });
  });

  suite('_requestDeleteHandler()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    function fire(id, cancelable) {
      const e = new CustomEvent('request-object-deleted', {
        bubbles: true,
        cancelable,
        detail: {
          id
        }
      });
      document.body.dispatchEvent(e);
      return e;
    }

    test('Does nothing when request is unknown', () => {
      const old = Object.assign({}, element.activeRequests[0]);
      fire('some-id');
      assert.deepEqual(element.activeRequests[0], old);
    });

    test('Does nothing when event is cancelable', () => {
      const old = Object.assign({}, element.activeRequests[0]);
      fire(element.activeRequests[0]._id, true);
      assert.deepEqual(element.activeRequests[0], old);
    });

    test('Clears request name', () => {
      fire(element.activeRequests[0]._id);
      assert.equal(element.activeRequests[0].name, '');
    });

    ['type', 'driveId', 'projects', '_id', '_rev', 'created', 'updated']
    .forEach((prop) => {
      test(`Clears "${prop}" property`, () => {
        element.activeRequests[0][prop] = 'value';
        fire(element.activeRequests[0]._id);
        assert.isUndefined(element.activeRequests[0][prop]);
      });
    });
  });

  suite('addRequestById()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    function modelFactory(e) {
      e.preventDefault();
      e.stopPropagation();
      e.detail.result = new Promise((resolve) => {
        const {id} = e.detail;
        let data;
        if (id instanceof Array) {
          data = DataGenerator.generateRequests({
            requestsSize: id.length
          });
          data.forEach((item, i) => item._id = id[i]);
        } else {
          data = DataGenerator.generateSavedItem();
          data._id = id;
        }
        resolve(data);
      });
    }

    test('Rejects when model not found', () => {
      element.addEventListener('request-object-read', function f(e) {
        element.removeEventListener('request-object-read', f);
        e.stopPropagation();
      });
      return element.addRequestById('saved', 'my-id')
      .then(() => {
        throw new Error('Should not resolve');
      })
      .catch((cause) => {
        assert.equal(cause.message, 'Request model not found');
      });
    });

    test('Calls dispatch with query arguments', () => {
      element.addEventListener('request-object-read', function f(e) {
        element.removeEventListener('request-object-read', f);
        e.stopPropagation();
      });
      const spy = sinon.spy(element, '_dispatch');
      element.addRequestById('saved', 'my-id').catch(() => {});
      assert.isTrue(spy.called);
      assert.equal(spy.args[0][0], 'request-object-read', 'Event type set');
      assert.equal(spy.args[0][1].type, 'saved');
      assert.equal(spy.args[0][1].id, 'my-id');
      assert.equal(spy.args[0][1].opts.restorePayload, true);
    });

    test('Sets "restoring" property', () => {
      element.addEventListener('request-object-read', modelFactory);
      element.addRequestById('saved', 'my-id').catch(() => {});
      element.removeEventListener('request-object-read', modelFactory);
      assert.isTrue(element.restoring);
    });

    test('Restores single request', () => {
      element.addEventListener('request-object-read', modelFactory);
      return element.addRequestById('saved', 'my-id')
      .then(() => {
        element.removeEventListener('request-object-read', modelFactory);
        assert.lengthOf(element.activeRequests, 1);
        assert.equal(element.activeRequests[0]._id, 'my-id');
      });
    });

    test('Restores multiple request', () => {
      element.addEventListener('request-object-read', modelFactory);
      return element.addRequestById('saved', ['r1', 'r2', 'r3'])
      .then(() => {
        element.removeEventListener('request-object-read', modelFactory);
        assert.lengthOf(element.activeRequests, 3);
        assert.equal(element.activeRequests[0]._id, 'r1');
        assert.equal(element.activeRequests[1]._id, 'r2');
        assert.equal(element.activeRequests[2]._id, 'r3');
      });
    });

    test('Re-sets restoring property', () => {
      element.addEventListener('request-object-read', modelFactory);
      return element.addRequestById('saved', 'my-id')
      .then(() => {
        element.removeEventListener('request-object-read', modelFactory);
        assert.isFalse(element.restoring);
      });
    });

    test('Updates request object if already exists', () => {
      const existing = DataGenerator.generateSavedItem();
      existing._id = 'r2';
      element.appendRequest(existing, {
        noAutoSelect: true
      });
      element.addEventListener('request-object-read', modelFactory);
      return element.addRequestById('saved', ['r1', 'r2', 'r3'])
      .then(() => {
        element.removeEventListener('request-object-read', modelFactory);
        assert.lengthOf(element.activeRequests, 3);
        assert.equal(element.activeRequests[0]._id, 'r2');
        assert.equal(element.activeRequests[1]._id, 'r1');
      });
    });

    test('Selectes last added', () => {
      element.addEventListener('request-object-read', modelFactory);
      return element.addRequestById('saved', ['r1', 'r2'])
      .then(() => {
        element.removeEventListener('request-object-read', modelFactory);
        assert.lengthOf(element.activeRequests, 2);
        assert.equal(element.selected, 1);
      });
    });
  });

  suite('replaceByRequestId()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element, 1);
    });

    function modelFactory(e) {
      e.preventDefault();
      e.stopPropagation();
      e.detail.result = Promise.resolve({_id: 'test'});
    }

    test('Calls clearWorkspace()', () => {
      element.addEventListener('request-object-read', modelFactory);
      const spy = sinon.spy(element, 'clearWorkspace');
      return element.replaceByRequestId('type', 'test')
      .then(() => {
        element.removeEventListener('request-object-read', modelFactory);
        assert.isTrue(spy.called, 'Function called');
        assert.isTrue(spy.args[0][0], 'Argument is set');
      });
    });

    test('Calls addRequestById()', () => {
      element.addEventListener('request-object-read', modelFactory);
      const spy = sinon.spy(element, 'addRequestById');
      return element.replaceByRequestId('saved', 'test')
      .then(() => {
        element.removeEventListener('request-object-read', modelFactory);
        assert.isTrue(spy.called, 'Function called');
        assert.equal(spy.args[0][0], 'saved', 'Type argument is set');
        assert.equal(spy.args[0][1], 'test', 'Id argument is set');
      });
    });
  });

  suite('clearWorkspace()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element, 1);
    });

    test('Calls __removeAllPanels()', () => {
      const spy = sinon.spy(element, '__removeAllPanels');
      element.clearWorkspace(true);
      assert.isTrue(spy.called);
    });

    test('Request panels are not in the DOM', () => {
      element.clearWorkspace(true);
      const nodes = element.shadowRoot.querySelectorAll('request-panel');
      assert.lengthOf(nodes, 0);
    });

    test('Sets activeRequests to empty array', () => {
      element.clearWorkspace(true);
      assert.deepEqual(element.activeRequests, []);
    });

    test('Clears selection', () => {
      element.selected = 0;
      element.clearWorkspace(true);
      assert.isUndefined(element.selected);
    });

    test('Will not call addEmptyRequest() when argument is true', (done) => {
      const spy = sinon.spy(element, 'addEmptyRequest');
      element.clearWorkspace(true);
      afterNextRender(element, () => {
        assert.isFalse(spy.called);
        done();
      });
    });

    test('Calls addEmptyRequest() when no argument', (done) => {
      const spy = sinon.spy(element, 'addEmptyRequest');
      element.clearWorkspace();
      afterNextRender(element, () => {
        assert.isTrue(spy.called);
        done();
      });
    });
  });

  suite('appendByProject()', () => {
    let project;
    let requests;
    suiteSetup(() => {
      return DataGenerator.insertSavedRequestData()
      .then((result) => {
        project = result.projects.find((item) => !!item.requests.length);
        if (!project) {
          throw new Error('Chance did not produced project with requests');
        }
        requests = result.requests.filter((item) => item.projects && item.projects.indexOf(project._id) !== -1);
      });
    });

    suiteTeardown(() => {
      return DataGenerator.destroySavedRequestData();
    });

    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    test('Restores by project ID', () => {
      return element.appendByProject(project._id)
      .then(() => {
        assert.lengthOf(element.activeRequests, requests.length);
      });
    });

    test('Restores project.requests list', () => {
      return element.appendByProject(project)
      .then(() => {
        assert.lengthOf(element.activeRequests, requests.length);
      });
    });

    test('Restores by project._id', () => {
      const copy = Object.assign({}, project);
      delete copy.requests;
      return element.appendByProject(project)
      .then(() => {
        assert.lengthOf(element.activeRequests, requests.length);
      });
    });

    test('Throws when no requests to request', () => {
      const copy = Object.assign({}, project);
      delete copy.requests;
      delete copy._id;
      assert.throws(() => {
        element.appendByProject(copy);
      }, 'Unknown configuration');
    });

    test('Throws when no argument', () => {
      assert.throws(() => {
        element.appendByProject();
      }, 'Expecting argument.');
    });

    test('Throws when event not handled', () => {
      element.addEventListener('request-project-list', function f(e) {
        element.removeEventListener('request-project-list', f);
        e.stopPropagation();
      });
      assert.throws(() => {
        element.appendByProject(project._id);
      }, 'Request model not found');
    });
  });

  suite('replaceByProject()', () => {
    let project;
    let requests;
    suiteSetup(() => {
      return DataGenerator.insertSavedRequestData()
      .then((result) => {
        project = result.projects.find((item) => !!item.requests.length);
        if (!project) {
          throw new Error('Chance did not produced project with requests');
        }
        requests = result.requests.filter((item) => item.projects && item.projects.indexOf(project._id) !== -1);
      });
    });

    suiteTeardown(() => {
      return DataGenerator.destroySavedRequestData();
    });

    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element, requests.length + 1);
    });

    test('Calls clearWorkspace()', () => {
      const spy = sinon.spy(element, 'clearWorkspace');
      return element.replaceByProject(project)
      .then(() => {
        assert.isTrue(spy.called, 'Function called');
        assert.isTrue(spy.args[0][0], 'Argument is set');
      });
    });

    test('Calls appendByProject()', () => {
      const spy = sinon.spy(element, 'appendByProject');
      return element.replaceByProject(project)
      .then(() => {
        assert.isTrue(spy.called, 'Function called');
        assert.deepEqual(spy.args[0][0], project, 'Argument is set');
      });
    });

    test('Replaces requests list', () => {
      return element.replaceByProject(project)
      .then(() => {
        assert.lengthOf(element.activeRequests, requests.length);
      });
    });
  });

  suite('_openProjectHandler()', () => {
    let project;
    let requests;
    suiteSetup(() => {
      return DataGenerator.insertSavedRequestData()
      .then((result) => {
        project = result.projects.find((item) => !!item.requests.length);
        if (!project) {
          throw new Error('Chance did not produced project with requests');
        }
        requests = result.requests.filter((item) => item.projects && item.projects.indexOf(project._id) !== -1);
      });
    });

    suiteTeardown(() => {
      return DataGenerator.destroySavedRequestData();
    });

    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element, requests.length + 1);
    });

    function fire(project, replace) {
      const e = new CustomEvent('workspace-open-project-requests', {
        bubbles: true,
        cancelable: true,
        detail: {
          project,
          replace
        }
      });
      document.body.dispatchEvent(e);
      return e;
    }

    test('Calls replaceByProject()', () => {
      const spy = sinon.spy(element, 'replaceByProject');
      const e = fire(project, true);
      assert.isTrue(spy.called);
      return e.detail.result;
    });

    test('Calls appendByProject()', () => {
      const spy = sinon.spy(element, 'appendByProject');
      const e = fire(project, false);
      assert.isTrue(spy.called);
      return e.detail.result;
    });

    test('Cancels the event', () => {
      const e = fire(project, false);
      assert.isTrue(e.defaultPrevented);
      return e.detail.result;
    });

    test('Ignores cancelled events', () => {
      const spy = sinon.spy(element, 'appendByProject');
      const e = {
        preventDefault: () => {},
        defaultPrevented: true,
        detail: {
          project,
          replace: true
        }
      };
      element._openProjectHandler(e);
      assert.isFalse(spy.called);
    });
  });

  suite('replaceByRequestsData()', () => {
    let element;
    let requests;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element);
      requests = DataGenerator.generateRequests({
        requestsSize: 3
      });
    });

    test('Calls clearWorkspace()', () => {
      const spy = sinon.spy(element, 'clearWorkspace');
      element.replaceByRequestsData(requests);
      assert.isTrue(spy.called, 'Function called');
      assert.isTrue(spy.args[0][0], 'Argument is set');
    });

    test('Sets restoring', () => {
      const spy = sinon.spy(element, '_setRestoring');
      element.replaceByRequestsData(requests);
      assert.equal(spy.callCount, 2);
      assert.isTrue(spy.args[0][0], 'First time argument is true');
      assert.isFalse(spy.args[1][0], 'Second time argument is false');
    });

    test('Sets refreshTabs()', () => {
      const spy = sinon.spy(element, 'refreshTabs');
      element.replaceByRequestsData(requests);
      assert.isTrue(spy.called);
    });

    test('Calls appendRequest() for each request', () => {
      const spy = sinon.spy(element, 'appendRequest');
      element.replaceByRequestsData(requests);
      assert.equal(spy.callCount, 3);
      assert.deepEqual(spy.args[0][0], requests[0], 'Request argument is set');
      assert.isTrue(spy.args[0][1].skipPositionCheck, 'skipPositionCheck is set');
      assert.isTrue(spy.args[0][1].noAutoSelect, 'noAutoSelect is set');
    });

    test('Sets request _id property if missing', () => {
      delete requests[0]._id;
      element.replaceByRequestsData(requests);
      assert.typeOf(requests[0]._id, 'string');
    });

    test('Sets selected to latest request', () => {
      element.replaceByRequestsData(requests);
      assert.equal(element.selected, 2);
    });
  });

  suite('getActivePanel()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element);
    });

    test('Returns panel for selected', () => {
      element.selected = 0;
      const result = element.getActivePanel();
      assert.ok(result);
    });

    test('Undefined if no selected request', () => {
      const result = element.getActivePanel();
      assert.isUndefined(result);
    });

    test('Undefined if no panel for request id', () => {
      element.selected = 0;
      element.activeRequests[0]._id = 'some-id';
      const result = element.getActivePanel();
      assert.isUndefined(result);
    });
  });

  suite('sendCurrent()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element);
      element.selected = 0;
    });

    test('Calls getActivePanel()', () => {
      const spy = sinon.spy(element, 'getActivePanel');
      element.sendCurrent();
      assert.isTrue(spy.called);
    });

    test('Calls send() on the panel', () => {
      const panel = element.getActivePanel();
      const spy = sinon.spy(panel, 'send');
      element.sendCurrent();
      assert.isTrue(spy.called);
    });
  });

  suite('abortCurrent()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element);
      element.selected = 0;
    });

    test('Calls getActivePanel()', () => {
      const spy = sinon.spy(element, 'getActivePanel');
      element.abortCurrent();
      assert.isTrue(spy.called);
    });

    test('Calls abort() on the panel', () => {
      const panel = element.getActivePanel();
      const spy = sinon.spy(panel, 'abort');
      element.abortCurrent();
      assert.isTrue(spy.called);
    });
  });

  suite('clearCurrent()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element);
      element.selected = 0;
    });

    test('Calls getActivePanel()', () => {
      const spy = sinon.spy(element, 'getActivePanel');
      element.clearCurrent();
      assert.isTrue(spy.called);
    });

    test('Calls clear() on the panel', () => {
      const panel = element.getActivePanel();
      const spy = sinon.spy(panel, 'clear');
      element.clearCurrent();
      assert.isTrue(spy.called);
    });
  });

  suite('abortAll()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element);
    });

    test('Calls abort() on request panel', () => {
      element.selected = 1;
      const panel = element.getActivePanel();
      panel.loading = true;
      const spy = sinon.spy(panel, 'abort');
      element.abortAll();
      assert.isTrue(spy.called);
    });

    test('Skips panels that are not loading', () => {
      element.selected = 1;
      const panel = element.getActivePanel();
      panel.loading = false;
      const spy = sinon.spy(panel, 'abort');
      element.abortAll();
      assert.isFalse(spy.called);
    });
  });

  suite('duplicateTab()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element);
    });

    test('Does nothing if index is incorrect', () => {
      const spy = sinon.spy(element, 'appendRequest');
      element.duplicateTab(3);
      assert.isFalse(spy.called);
    });

    test('Calls appendRequest() with arguments', () => {
      const spy = sinon.spy(element, 'appendRequest');
      element.duplicateTab(1);
      assert.isTrue(spy.called, 'Function called');
      assert.equal(spy.args[0][0].url, element.activeRequests[1].url);
      assert.isTrue(spy.args[0][1].skipPositionCheck);
    });

    test('Calls _clearRequestMeta()', () => {
      const spy = sinon.spy(element, '_clearRequestMeta');
      element.duplicateTab(1);
      assert.isTrue(spy.called);
      assert.isTrue(spy.args[0][1]);
    });

    test('Removes request properties', () => {
      const request = element.activeRequests[0];
      request.name = 'test-name';
      request.driveId = 'test-drive-id';
      request.projects = ['project-id'];
      request.type = 'saved';
      request.legacyProject = 'abc';
      element.duplicateTab(0);
      assert.lengthOf(element.activeRequests, 3);
      const copy = element.activeRequests[2];
      assert.notEqual(copy._id, request._id, + '_id is cleared');
      ['_rev', 'name', 'driveId', 'projects', 'type', 'legacyProject']
      .forEach((prop) => {
        assert.isUndefined(copy[prop], prop + ' is cleared');
      });
    });
  });

  suite('_clearRequestMeta()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    test('Removes properties with "_"', () => {
      const obj = {
        _a: true,
        b: true
      };
      element._clearRequestMeta(obj);
      assert.isUndefined(obj._a);
    });

    test('Keeps other properties', () => {
      const obj = {
        _a: true,
        b: true
      };
      element._clearRequestMeta(obj);
      assert.isTrue(obj.b);
    });

    test('Will not clear _id', () => {
      const obj = {
        _id: 'true',
        _rev: 'true'
      };
      element._clearRequestMeta(obj);
      assert.equal(obj._id, 'true');
    });

    test('Will not clear _rev', () => {
      const obj = {
        _id: 'true',
        _rev: 'true'
      };
      element._clearRequestMeta(obj);
      assert.equal(obj._rev, 'true');
    });

    test('Removes _id when includeIds is set', () => {
      const obj = {
        _id: 'true',
        _rev: 'true'
      };
      element._clearRequestMeta(obj, true);
      assert.isUndefined(obj._id);
    });

    test('Removes _rev when includeIds is set', () => {
      const obj = {
        _id: 'true',
        _rev: 'true'
      };
      element._clearRequestMeta(obj, true);
      assert.isUndefined(obj._rev);
    });
  });

  suite('closeActiveTab()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      element.selected = 0;
    });

    test('Calls removeRequest() with argument', () => {
      const spy = sinon.spy(element, 'removeRequest');
      element.closeActiveTab();
      assert.isTrue(spy.called);
      assert.equal(spy.args[0][0], 0);
    });

    test('Removes the request', () => {
      element.closeActiveTab();
      assert.deepEqual(element.activeRequests, []);
    });
  });

  suite('openWebUrlInput()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      flush(() => done());
    });

    test('Opens the dialog', () => {
      element.openWebUrlInput();
      assert.isTrue(element.$.webUrlInput.opened);
    });
  });
  </script>
</body>
</html>
