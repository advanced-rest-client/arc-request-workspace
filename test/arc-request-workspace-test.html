<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>arc-request-workspace test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../arc-request-workspace.html">
  <link rel="import" href="../../arc-data-generator/arc-data-generator.html">
  <link rel="import" href="../../arc-models/project-model.html">
  <link rel="import" href="../../arc-models/request-model.html">
  <link rel="import" href="../../arc-models/variables-model.html">
  <link rel="import" href="../../iron-test-helpers/mock-interactions.html">
</head>
<body>
  <project-model></project-model>
  <request-model></request-model>
  <variables-model></variables-model>

  <test-fixture id="Basic">
    <template>
      <arc-request-workspace no-auto-projects></arc-request-workspace>
    </template>
  </test-fixture>

  <test-fixture id="NoAuto">
    <template>
      <arc-request-workspace no-auto-projects no-auto-restore></arc-request-workspace>
    </template>
  </test-fixture>

  <script>
  /* global DataGenerator, MockInteractions */
  function wrapStateReadEvent(element) {
    element.addEventListener('workspace-state-read', function f(e) {
      element.removeEventListener('workspace-state-read', f);
      e.preventDefault();
      e.detail.result = Promise.resolve({});
    });
  }

  function addRequests(element, size) {
    const requests = DataGenerator.generateRequests({
      requestsSize: size || 2
    });
    for (let i = 0; i < requests.length; i++) {
      requests[i].name = 'Test request name #' + i;
      element.__addPanel(requests[i]);
    }
    element.activeRequests = requests;
  }

  suite('Basics', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      wrapStateReadEvent(element);
    });

    test('selected is eventually set', (done) => {
      element.addEventListener('selected-changed', function f() {
        element.removeEventListener('selected-changed', f);
        done();
      });
    });

    test('activeRequests has default value', () => {
      assert.typeOf(element.activeRequests, 'array');
      assert.lengthOf(element.activeRequests, 0);
    });

    test('restoring is false when initializing', () => {
      assert.isFalse(element.restoring);
    });
  });

  suite('_dispatch()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });
    const eName = 'test-event';
    const eDetail = 'test-detail';
    test('Dispatches an event', () => {
      const spy = sinon.spy();
      element.addEventListener(eName, spy);
      element._dispatch(eName);
      assert.isTrue(spy.called);
    });
    test('Returns the event', () => {
      const e = element._dispatch(eName);
      assert.typeOf(e, 'customevent');
    });
    test('Event is cancelable by default', () => {
      const e = element._dispatch(eName);
      assert.isTrue(e.cancelable);
    });
    test('Event is composed', () => {
      const e = element._dispatch(eName);
      if (typeof e.composed !== 'undefined') {
        assert.isTrue(e.composed);
      }
    });
    test('Event bubbles', () => {
      const e = element._dispatch(eName);
      assert.isTrue(e.bubbles);
    });
    test('Event is not cancelable when set', () => {
      const e = element._dispatch(eName, eDetail, false);
      assert.isFalse(e.cancelable);
    });
    test('Event has detail', () => {
      const e = element._dispatch(eName, eDetail);
      assert.equal(e.detail, eDetail);
    });
  });

  suite('_computeTabName()', () => {
    function restoreHandler(e) {
      e.preventDefault();
      e.detail.result = new Promise((resolve) => {
        const saved = DataGenerator.generateSavedRequestData({
          requestsSize: 3
        });
        const history = DataGenerator.generateHistoryRequestsData({
          requestsSize: 3
        });
        const requests = history.concat(saved.requests);
        const result = {
          selected: 1,
          environment: 'test-env',
          requests
        };
        resolve(result);
      });
    }
    let element;
    setup(() => {
      window.addEventListener('workspace-state-read', restoreHandler);
      element = fixture('Basic');
    });

    teardown(() => {
      window.removeEventListener('workspace-state-read', restoreHandler);
    });

    test('Returns "New request" for undefined item', () => {
      const result = element._computeTabName();
      assert.equal(result, 'New request');
    });

    test('Returns item name if exists', () => {
      const result = element._computeTabName('test-name');
      assert.equal(result, 'test-name');
    });

    test('Returns URL if item name does not exists', () => {
      const result = element._computeTabName(undefined, 'test-url');
      assert.equal(result, 'test-url');
    });

    test('Returns "New request" otherwise', () => {
      const result = element._computeTabName('', '');
      assert.equal(result, 'New request');
    });
  });

  suite('appendRequest()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    test('Adds empty request to the list of active requests', () => {
      element.appendRequest({method: 'x-test'});
      assert.lengthOf(element.activeRequests, 1);
    });

    test('Added request has an id', () => {
      element.appendRequest({method: 'x-test'});
      assert.typeOf(element.activeRequests[0]._id, 'string');
    });

    test('Eventually sets request data', () => {
      element.appendRequest({method: 'x-test'});
      assert.equal(element.activeRequests[0].method, 'x-test');
    });

    test('Selects newly added request', () => {
      element.appendRequest({});
      assert.equal(element.selected, 0);
    });

    test('Returns index of created request', () => {
      const result = element.appendRequest({});
      assert.equal(result, 0);
    });

    test('Won\'t set ID if already exists', () => {
      const request = {
        _id: 'test-id',
        url: 'http:api.domain.com'
      };
      element.appendRequest(request);
      assert.deepEqual(element.activeRequests[0], request);
    });

    test('Won\'t add second empty request', () => {
      element.appendRequest({});
      element.appendRequest({});
      assert.lengthOf(element.activeRequests, 1);
    });

    test('Adds two empty requests when skipPositionCheck is set', () => {
      element.appendRequest({});
      element.appendRequest({}, {skipPositionCheck: true});
      assert.lengthOf(element.activeRequests, 2);
    });

    test('Won\'t select added request when noAutoSelect is set', () => {
      element.appendRequest({});
      element.appendRequest({}, {noAutoSelect: true});
      assert.equal(element.selected, 0);
    });
  });

  suite('addEmptyRequest()', () => {
    let element;
    setup(() => {
      element = fixture('NoAuto');
    });

    test('Adds request to the list of active requests', () => {
      element.addEmptyRequest();
      assert.lengthOf(element.activeRequests, 1);
      const r = element.activeRequests[0];
      assert.equal(r.method, 'GET');
      assert.equal(r.url, 'http://');
    });

    test('Selects newly added request', () => {
      element.addEmptyRequest();
      assert.equal(element.selected, 0);
    });
  });

  suite('updateRequestObject()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element);
      flush(() => done());
    });

    test('Adds _id to the request', () => {
      const request = DataGenerator.generateSavedItem();
      delete request._id;
      element.updateRequestObject(request, 0);
      assert.typeOf(request._id, 'string');
    });

    test('Calls __updatePanelRequest()', () => {
      const spy = sinon.spy(element, '__updatePanelRequest');
      const request = DataGenerator.generateSavedItem();
      element.updateRequestObject(request, 1);
      assert.isTrue(spy.called);
    });

    test('Updates panel id', () => {
      const request = DataGenerator.generateSavedItem();
      element.updateRequestObject(request, 0);
      const node = element.shadowRoot.querySelector(`request-panel[data-id="${request._id}"]`);
      assert.ok(node);
    });

    test('Sets active request', () => {
      const request = DataGenerator.generateSavedItem();
      element.updateRequestObject(request, 0);
      assert.deepEqual(element.activeRequests[0], request);
    });

    test('Does nothing when no active request for the index', () => {
      const spy = sinon.spy(element, '__updatePanelRequest');
      const request = DataGenerator.generateSavedItem();
      element.updateRequestObject(request, 10);
      assert.isFalse(spy.called);
    });
  });

  suite('_closeRequest()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element);
      flush(() => done());
    });

    test('Closes request after button click', () => {
      const spy = sinon.spy(element, 'removeRequest');
      const button = element.shadowRoot.querySelectorAll('.close-icon')[1];
      MockInteractions.tap(button);
      assert.isTrue(spy.called);
    });

    test('Closes second request', () => {
      const spy = sinon.spy(element, 'removeRequest');
      const button = element.shadowRoot.querySelectorAll('.close-icon')[1];
      MockInteractions.tap(button);
      assert.equal(spy.args[0][0], 1);
    });

    test('Does nothing when event target has no data-index', () => {
      const spy = sinon.spy(element, 'removeRequest');
      const button = element.shadowRoot.querySelectorAll('.close-icon')[1];
      button.removeAttribute('data-index');
      MockInteractions.tap(button);
      assert.isFalse(spy.called);
    });
  });

  suite('removeRequest()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element);
      flush(() => done());
    });

    test('Removes request from activeRequests', () => {
      element.removeRequest(0);
      assert.lengthOf(element.activeRequests, 1);
    });

    test('Removes request at the index', () => {
      const idB = element.activeRequests[1]._id;
      element.removeRequest(0);
      assert.equal(element.activeRequests[0]._id, idB);
    });

    test('Calls __removePanel()', () => {
      const id = element.activeRequests[0]._id;
      const spy = sinon.spy(element, '__removePanel');
      element.removeRequest(0);
      assert.isTrue(spy.called);
      assert.equal(spy.args[0][0], id);
    });

    test('Removes the panel', () => {
      const id = element.activeRequests[0]._id;
      element.removeRequest(0);
      const node = element.shadowRoot.querySelector(`request-panel[data-id="${id}"]`);
      assert.notOk(node);
    });

    test('re-sets the selection when first request which is selected', () => {
      const spy = sinon.spy();
      element.selected = 0;
      element.addEventListener('selected-changed', spy);
      element.removeRequest(0);
      assert.equal(spy.callCount, 2);
      assert.equal(spy.args[0][0].detail.value, undefined);
      assert.equal(spy.args[1][0].detail.value, 0);
    });

    test('Cheges selection if higher than index', () => {
      element.selected = 1;
      element.removeRequest(0);
      assert.equal(element.selected, 0);
    });

    test('Adds empty request when no more requests', (done) => {
      element.selected = 0;
      element.removeRequest(0);
      const spy = sinon.spy(element, 'addEmptyRequest');
      element.removeRequest(0);
      Polymer.RenderStatus.afterNextRender(element, () => {
        assert.isTrue(spy.called);
        done();
      });
    });
  });

  suite('refreshTabs()', () => {
    let element;
    setup((done) => {
      element = fixture('NoAuto');
      addRequests(element, 1);
      flush(() => done());
    });

    test('Calls notifyResize() on tabs', () => {
      const node = element.shadowRoot.querySelector('paper-tabs');
      const spy = sinon.spy(node, 'notifyResize');
      element.refreshTabs();
      assert.isTrue(spy.called);
    });
  });

  suite('_dispatchExportData()', () => {
    let element;
    setup(() => {
      element = fixture('Basic');
      wrapStateReadEvent(element);
    });

    test('Dispatches "export-data" event', () => {
      const spy = sinon.spy();
      element.addEventListener('export-data', spy);
      element._dispatchExportData();
      assert.isTrue(spy.called);
    });

    test('Returns the event', () => {
      const result = element._dispatchExportData();
      assert.typeOf(result, 'customevent');
    });

    test('Event is cancelable', () => {
      const result = element._dispatchExportData();
      assert.isTrue(result.cancelable);
    });

    test('Event is composed', () => {
      const result = element._dispatchExportData();
      assert.isTrue(result.composed);
    });

    test('Event bubbles', () => {
      const result = element._dispatchExportData();
      assert.isTrue(result.bubbles);
    });

    test('Event has detail object', () => {
      const result = element._dispatchExportData();
      assert.typeOf(result.detail, 'object');
    });

    test('Detail has type', () => {
      const result = element._dispatchExportData();
      assert.equal(result.detail.type, 'arc-export');
    });

    test('Detail has destination', () => {
      const result = element._dispatchExportData('test');
      assert.equal(result.detail.destination, 'test');
    });

    test('Detail has file', () => {
      const result = element._dispatchExportData();
      assert.equal(result.detail.file, 'arc-saved-export.json');
    });

    test('Detail has kind', () => {
      const result = element._dispatchExportData();
      assert.equal(result.detail.kind, 'ARC#SavedExport');
    });

    test('Detail has data with "requests"', () => {
      const result = element._dispatchExportData('test', true);
      assert.typeOf(result.detail.data, 'object');
      assert.isTrue(result.detail.data.requests);
    });
  });

  suite('_exportRequest()', () => {
    let element;
    let list;
    setup(() => {
      element = fixture('Basic');
      wrapStateReadEvent(element);
      list = DataGenerator.generateSavedRequestData();
    });

    test('Dispatches export event', () => {
      element.addEventListener('export-data', function f(e) {
        element.removeEventListener('export-data', f);
        e.preventDefault();
        e.detail.result = Promise.resolve();
      });
      const spy = sinon.spy();
      element.addEventListener('export-data', spy);
      element._exportRequest(list, 'file');
      assert.isTrue(spy.called);
    });

    test('Opens error toast when export not found', (done) => {
      flush(() => {
        element._exportRequest(list, 'file');
        const toast = element.shadowRoot.querySelector('#noExport');
        assert.isTrue(toast.opened);
        done();
      });
    });

    test('Opens drive confirmation toast', (done) => {
      element.addEventListener('export-data', function f(e) {
        element.removeEventListener('export-data', f);
        e.preventDefault();
        e.detail.result = Promise.resolve();
      });
      element._exportRequest(list, 'drive');
      flush(() => {
        const toast = element.shadowRoot.querySelector('#driveSaved');
        assert.isTrue(toast.opened);
        done();
      });
    });
  });
  </script>
</body>
</html>
