<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>ArcWorkspaceDndMixin test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../arc-request-workspace.html">
  <link rel="import" href="../../arc-data-generator/arc-data-generator.html">
  <style>
  html {
    --paper-tabs-selection-bar-color: red;
    --paper-tabs-selection-bar_-_border-color: yellow;
  }
  </style>
</head>
<body>
  <test-fixture id="Draggable">
    <template>
      <arc-request-workspace no-auto-projects no-auto-restore draggable-enabled></arc-request-workspace>
    </template>
  </test-fixture>

  <script>
  /* global DataGenerator, MockInteractions */
  suite('ArcWorkspaceDndMixin', () => {
    function stateRestoreHandler(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    function stateStoreHandler(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    suiteSetup(() => {
      window.addEventListener('workspace-state-read', stateRestoreHandler);
      window.addEventListener('workspace-state-store', stateStoreHandler);
    });

    suiteTeardown(() => {
      window.removeEventListener('workspace-state-read', stateRestoreHandler);
      window.removeEventListener('workspace-state-store', stateStoreHandler);
    });

    function addRequests(element, size) {
      const requests = DataGenerator.generateRequests({
        requestsSize: size || 2
      });
      for (let i = 0; i < requests.length; i++) {
        requests[i].name = 'Test request name #' + i;
        element.__addPanel(requests[i]);
      }
      element.activeRequests = requests;
    }

    class MockedDataTransfer {
      constructor() {
        this._data = {};
        this.effectAllowed = 'none';
        this.dropEffect = 'none';
      }
      setData(type, data) {
        this._data[type] = String(data);
      }
      getData(type) {
        return this._data[type] || '';
      }
      get types() {
        return Object.keys(this._data);
      }
    }

    suite('_dragStart()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 1);
        element._startReorderDrag = () => {};
        element._removeTabSelectionColor = () => {};
        flush(() => done());
      });

      function dispatch(element) {
        const node = element.shadowRoot.querySelector('.tabs paper-tab');
        const e = new Event('dragstart');
        e.dataTransfer = new MockedDataTransfer();
        node.dispatchEvent(e);
      }

      test('Calls _dragStart()', (done) => {
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        assert.isTrue(spy.called);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Sets arc/request-object transfer data', (done) => {
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        const data = spy.args[0][0].dataTransfer.getData('arc/request-object');
        assert.typeOf(data, 'string');
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Sets arc/history-request data for history item', (done) => {
        element.activeRequests[0].type = 'history';
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        const data = spy.args[0][0].dataTransfer.getData('arc/history-request');
        assert.equal(data, element.activeRequests[0]._id);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Sets arc/saved-request data for saved data', (done) => {
        element.activeRequests[0].type = 'saved';
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        const data = spy.args[0][0].dataTransfer.getData('arc/saved-request');
        assert.equal(data, element.activeRequests[0]._id);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Sets arc-source/requests-workspace transfer data', (done) => {
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        const data = spy.args[0][0].dataTransfer.getData('arc-source/requests-workspace');
        assert.equal(data, element.activeRequests[0]._id);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Ignores event when draggableEnabled not set', (done) => {
        element.draggableEnabled = false;
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        assert.isUndefined(spy.args[0][0].dropEffect);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Sets effectAllowed', (done) => {
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        assert.equal(spy.args[0][0].dataTransfer.effectAllowed, 'copyMove');
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Calls _startReorderDrag()', (done) => {
        const spy = sinon.spy(element, '_startReorderDrag');
        dispatch(element);
        Polymer.RenderStatus.afterNextRender(element, () => {
          assert.isTrue(spy.called);
          done();
        });
      });

      test('Calls _removeTabSelectionColor()', (done) => {
        const spy = sinon.spy(element, '_removeTabSelectionColor');
        dispatch(element);
        Polymer.RenderStatus.afterNextRender(element, () => {
          assert.isTrue(spy.called);
          done();
        });
      });
    });

    suite('_removeTabSelectionColor()', () => {
      let element;
      let node;
      setup(function() {
        element = fixture('Draggable');
        node = document.createElement('div');
      });

      test('Sets __tabsSelectionColor', () => {
        element._removeTabSelectionColor(node);
        assert.equal(element.__tabsSelectionColor, 'red');
      });

      test('Sets __tabsSelectionColor2', () => {
        element._removeTabSelectionColor(node);
        assert.equal(element.__tabsSelectionColor2, 'yellow');
      });

      test('Sets --paper-tabs-selection-bar-color variable', () => {
        element._removeTabSelectionColor(node);
        const style = getComputedStyle(element.$.tabs);
        const result = style.getPropertyValue('--paper-tabs-selection-bar-color').trim();
        assert.equal(result, 'transparent');
      });

      test('Sets --paper-tabs-selection-bar_-_border-color variable', () => {
        element._removeTabSelectionColor(node);
        const style = getComputedStyle(element.$.tabs);
        const result = style.getPropertyValue('--paper-tabs-selection-bar_-_border-color').trim();
        assert.equal(result, 'transparent');
      });

      test('Sets __tabsInitialDisplay', () => {
        element._removeTabSelectionColor(node);
        assert.typeOf(element.__tabsInitialDisplay, 'string');
      });

      test('Hiddes passed node', () => {
        element._removeTabSelectionColor(node);
        assert.equal(node.style.visibility, 'hidden');
      });
    });

    suite('_startReorderDrag()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 1);
        element._removeTabSelectionColor = () => {};
        flush(() => done());
      });

      function dispatch(element) {
        const node = element.shadowRoot.querySelector('.tabs paper-tab');
        const e = new Event('dragstart');
        e.dataTransfer = new MockedDataTransfer();
        node.dispatchEvent(e);
      }

      test('Sets __reorderInfo object properties', (done) => {
        dispatch(element);
        Polymer.RenderStatus.afterNextRender(element, () => {
          assert.equal(element.__reorderInfo.type, 'track', 'Type is set');
          assert.ok(element.__reorderInfo.dragElement, 'dragElement is set');
          assert.ok(element.__reorderInfo.dragModel, 'dragModel is set');
          assert.equal(element.__reorderInfo.dragIndex, 0, 'dragIndex is set');
          done();
        });
      });

      test('Blocks the editors', (done) => {
        const spy = sinon.spy(element, '_blockEditors');
        dispatch(element);
        Polymer.RenderStatus.afterNextRender(element, () => {
          assert.isTrue(spy.called);
          done();
        });
      });
    });

    suite('_dragEnd()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
        element._finishReorder = () => {};
        element._unblockEditors = () => {};
        element.refreshTabs = () => {};
      });

      function createEvent() {
        const e = new Event('dragend');
        e.dataTransfer = new MockedDataTransfer();
        return e;
      }

      test('Does nothing when initial state', () => {
        const spy = sinon.spy(element, '_finishReorder');
        const e = createEvent();
        element._dragEnd(e);
        assert.isFalse(spy.called);
      });

      test('Calls _finishReorder()', () => {
        element.__reorderInfo.type = 'track';
        const spy = sinon.spy(element, '_finishReorder');
        const e = createEvent();
        element._dragEnd(e);
        assert.isTrue(spy.args[0][0] === e);
      });

      test('Calls refreshTabs()', () => {
        element.__reorderInfo.type = 'track';
        const spy = sinon.spy(element, 'refreshTabs');
        const e = createEvent();
        element._dragEnd(e);
        assert.isTrue(spy.called);
      });

      test('Calls _unblockEditors()', () => {
        element.__reorderInfo.type = 'track';
        const spy = sinon.spy(element, '_unblockEditors');
        const e = createEvent();
        element._dragEnd(e);
        assert.isTrue(spy.called);
      });
    });

    suite('_dragoverHandler()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        element._reorderDragover = () => {};
        element._newTabDragover = () => {};
        flush(() => done());
      });

      function dispatch(element, types) {
        if (!types) {
          types = ['arc/request-object'];
        }
        const e = new Event('dragover', {cancelable: true});
        e.dataTransfer = new MockedDataTransfer();
        types.forEach((type) => {
          e.dataTransfer.setData(type, 'test');
        });
        const node = element.shadowRoot.querySelector('.tabs');
        node.dispatchEvent(e);
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dragoverHandler();
        // no error
      });

      test('Ignores event when supported type is not set', () => {
        const spy = sinon.spy(element, '_newTabDragover');
        dispatch(element, ['other']);
        assert.isFalse(spy.called);
      });

      test('Handles the event when arc/request-object', () => {
        const spy = sinon.spy(element, '_newTabDragover');
        dispatch(element);
        assert.isTrue(spy.called);
      });

      test('Handles the event when arc/project-object', () => {
        const spy = sinon.spy(element, '_newTabDragover');
        dispatch(element, ['arc/project-object']);
        assert.isTrue(spy.called);
      });

      test('Cancels the event', () => {
        const e = dispatch(element);
        assert.isTrue(e.defaultPrevented);
      });

      test('Sets dropEffect for new tab', () => {
        const e = dispatch(element);
        assert.equal(e.dataTransfer.dropEffect, 'copy');
      });

      test('Sets dropEffect for reorder', () => {
        const e = dispatch(element, ['arc/request-object', 'arc-source/requests-workspace']);
        assert.equal(e.dataTransfer.dropEffect, 'move');
      });

      test('Calls _reorderDragover()', () => {
        const spy = sinon.spy(element, '_reorderDragover');
        dispatch(element, ['arc/request-object', 'arc-source/requests-workspace']);
        assert.isTrue(spy.called);
      });
    });

    suite('_dragleaveHandler()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        flush(() => done());
      });

      function dispatch(element, types) {
        if (!types) {
          types = ['arc/request-object'];
        }
        const e = new Event('dragleave', {cancelable: true});
        e.dataTransfer = new MockedDataTransfer();
        types.forEach((type) => {
          e.dataTransfer.setData(type, 'test');
        });
        const node = element.shadowRoot.querySelector('.tabs');
        node.dispatchEvent(e);
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dragleaveHandler();
        // no error
      });

      test('Ignores event when supported type is not set', () => {
        const e = dispatch(element, ['other']);
        assert.isFalse(e.defaultPrevented);
      });

      test('Handles the event when arc/request-object', () => {
        const e = dispatch(element);
        assert.isTrue(e.defaultPrevented);
      });

      test('Handles the event when arc/project-object', () => {
        const e = dispatch(element, ['arc/project-object']);
        assert.isTrue(e.defaultPrevented);
      });

      test('Calls _removeDropPointer()', () => {
        const spy = sinon.spy(element, '_removeDropPointer');
        dispatch(element);
        assert.isTrue(spy.called);
      });

      test('Clears __dropPointerReference', () => {
        element.__dropPointerReference = 'test';
        dispatch(element);
        assert.isUndefined(element.__dropPointerReference);
      });
    });
  });
  </script>
</body>
</html>
