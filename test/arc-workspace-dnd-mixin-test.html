<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>ArcWorkspaceDndMixin test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <!-- CodeMirror + modes loader -->
  <script src="../../../codemirror/lib/codemirror.js"></script>
  <script src="../../../codemirror/addon/mode/loadmode.js"></script>
  <script src="../../../codemirror/mode/meta.js"></script>
  <!--Default set of parsers, add as many as you need -->
  <script src="../../../codemirror/mode/javascript/javascript.js"></script>
  <script src="../../../codemirror/mode/xml/xml.js"></script>
  <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <!-- JSON linter -->
  <script src="../../../jsonlint/lib/jsonlint.js"></script>
  <script src="../../../codemirror/addon/lint/lint.js"></script>
  <script src="../../../codemirror/addon/lint/json-lint.js"></script>
  <!-- Headers hint support -->
  <script src="../../../@advanced-rest-client/code-mirror-hint/headers-addon.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/show-hint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/hint-http-headers.js"></script>
  
  <style>
  html {
    --paper-tabs-selection-bar-color: red;
    --paper-tabs-selection-bar_-_border-color: yellow;
  }
  </style>
</head>
<body>
  <test-fixture id="Draggable">
    <template>
      <arc-request-workspace no-auto-projects no-auto-restore draggable-enabled></arc-request-workspace>
    </template>
  </test-fixture>

  <script type="module">
  import '../arc-request-workspace.js';
  import {DataGenerator} from '../../arc-data-generator/arc-data-generator.js';
  import * as MockInteractions from '../../../@polymer/iron-test-helpers/mock-interactions.js';
  import {afterNextRender} from '../../../@polymer/polymer/lib/utils/render-status.js';
  import sinon from '../../../sinon/pkg/sinon-esm.js';

  suite('ArcWorkspaceDndMixin', () => {
    function stateRestoreHandler(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    function stateStoreHandler(e) {
      e.preventDefault();
      e.detail.result = Promise.resolve();
    }

    suiteSetup(() => {
      window.addEventListener('workspace-state-read', stateRestoreHandler);
      window.addEventListener('workspace-state-store', stateStoreHandler);
    });

    suiteTeardown(() => {
      window.removeEventListener('workspace-state-read', stateRestoreHandler);
      window.removeEventListener('workspace-state-store', stateStoreHandler);
    });

    function addRequests(element, size) {
      const requests = DataGenerator.generateRequests({
        requestsSize: size || 2
      });
      for (let i = 0; i < requests.length; i++) {
        requests[i].name = 'Test request name #' + i;
        element.__addPanel(requests[i]);
      }
      element.activeRequests = requests;
    }

    class MockedDataTransfer {
      constructor() {
        this._data = {};
        this.effectAllowed = 'none';
        this.dropEffect = 'none';
      }
      setData(type, data) {
        this._data[type] = String(data);
      }
      getData(type) {
        return this._data[type] || '';
      }
      get types() {
        return Object.keys(this._data);
      }
    }

    suite('_dragStart()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 1);
        element._startReorderDrag = () => {};
        element._removeTabSelectionColor = () => {};
        flush(() => done());
      });

      function dispatch(element) {
        const node = element.shadowRoot.querySelector('.tabs paper-tab');
        const e = new Event('dragstart');
        e.dataTransfer = new MockedDataTransfer();
        node.dispatchEvent(e);
      }

      test('Calls _dragStart()', (done) => {
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        assert.isTrue(spy.called);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Sets arc/request-object transfer data', (done) => {
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        const data = spy.args[0][0].dataTransfer.getData('arc/request-object');
        assert.typeOf(data, 'string');
        afterNextRender(element, () => {
          done();
        });
      });

      test('Sets arc/history-request data for history item', (done) => {
        element.activeRequests[0].type = 'history';
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        const data = spy.args[0][0].dataTransfer.getData('arc/history-request');
        assert.equal(data, element.activeRequests[0]._id);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Sets arc/saved-request data for saved data', (done) => {
        element.activeRequests[0].type = 'saved';
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        const data = spy.args[0][0].dataTransfer.getData('arc/saved-request');
        assert.equal(data, element.activeRequests[0]._id);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Sets arc-source/requests-workspace transfer data', (done) => {
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        const data = spy.args[0][0].dataTransfer.getData('arc-source/requests-workspace');
        assert.equal(data, element.activeRequests[0]._id);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Ignores event when draggableEnabled not set', (done) => {
        element.draggableEnabled = false;
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        assert.isUndefined(spy.args[0][0].dropEffect);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Sets effectAllowed', (done) => {
        const spy = sinon.spy(element, '_dragStart');
        dispatch(element);
        assert.equal(spy.args[0][0].dataTransfer.effectAllowed, 'copyMove');
        afterNextRender(element, () => {
          done();
        });
      });

      test('Calls _startReorderDrag()', (done) => {
        const spy = sinon.spy(element, '_startReorderDrag');
        dispatch(element);
        afterNextRender(element, () => {
          assert.isTrue(spy.called);
          done();
        });
      });

      test('Calls _removeTabSelectionColor()', (done) => {
        const spy = sinon.spy(element, '_removeTabSelectionColor');
        dispatch(element);
        afterNextRender(element, () => {
          assert.isTrue(spy.called);
          done();
        });
      });
    });

    suite('_removeTabSelectionColor()', () => {
      let element;
      let node;
      setup(function() {
        element = fixture('Draggable');
        node = document.createElement('div');
      });

      test('Sets __tabsSelectionColor', () => {
        element._removeTabSelectionColor(node);
        assert.equal(element.__tabsSelectionColor, 'red');
      });

      test('Sets __tabsSelectionColor2', () => {
        element._removeTabSelectionColor(node);
        assert.equal(element.__tabsSelectionColor2, 'yellow');
      });

      test('Sets --paper-tabs-selection-bar-color variable', () => {
        element._removeTabSelectionColor(node);
        const style = getComputedStyle(element.$.tabs);
        const result = style.getPropertyValue('--paper-tabs-selection-bar-color').trim();
        assert.equal(result, 'transparent');
      });

      test('Sets --paper-tabs-selection-bar_-_border-color variable', () => {
        element._removeTabSelectionColor(node);
        const style = getComputedStyle(element.$.tabs);
        const result = style.getPropertyValue('--paper-tabs-selection-bar_-_border-color').trim();
        assert.equal(result, 'transparent');
      });

      test('Sets __tabsInitialDisplay', () => {
        element._removeTabSelectionColor(node);
        assert.typeOf(element.__tabsInitialDisplay, 'string');
      });

      test('Hiddes passed node', () => {
        element._removeTabSelectionColor(node);
        assert.equal(node.style.visibility, 'hidden');
      });
    });

    suite('_startReorderDrag()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 1);
        element._removeTabSelectionColor = () => {};
        flush(() => done());
      });

      function dispatch(element) {
        const node = element.shadowRoot.querySelector('.tabs paper-tab');
        const e = new Event('dragstart');
        e.dataTransfer = new MockedDataTransfer();
        node.dispatchEvent(e);
      }

      test('Sets __reorderInfo object properties', (done) => {
        dispatch(element);
        afterNextRender(element, () => {
          assert.equal(element.__reorderInfo.type, 'track', 'Type is set');
          assert.ok(element.__reorderInfo.dragElement, 'dragElement is set');
          assert.ok(element.__reorderInfo.dragModel, 'dragModel is set');
          assert.equal(element.__reorderInfo.dragIndex, 0, 'dragIndex is set');
          done();
        });
      });

      test('Blocks the editors', (done) => {
        const spy = sinon.spy(element, '_blockEditors');
        dispatch(element);
        afterNextRender(element, () => {
          assert.isTrue(spy.called);
          done();
        });
      });
    });

    suite('_dragEnd()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
        element._finishReorder = () => {};
        element._unblockEditors = () => {};
        element.refreshTabs = () => {};
      });

      function createEvent() {
        const e = new Event('dragend');
        e.dataTransfer = new MockedDataTransfer();
        return e;
      }

      test('Does nothing when initial state', () => {
        const spy = sinon.spy(element, '_finishReorder');
        const e = createEvent();
        element._dragEnd(e);
        assert.isFalse(spy.called);
      });

      test('Calls _finishReorder()', () => {
        element.__reorderInfo.type = 'track';
        const spy = sinon.spy(element, '_finishReorder');
        const e = createEvent();
        element._dragEnd(e);
        assert.isTrue(spy.args[0][0] === e);
      });

      test('Calls refreshTabs()', () => {
        element.__reorderInfo.type = 'track';
        const spy = sinon.spy(element, 'refreshTabs');
        const e = createEvent();
        element._dragEnd(e);
        assert.isTrue(spy.called);
      });

      test('Calls _unblockEditors()', () => {
        element.__reorderInfo.type = 'track';
        const spy = sinon.spy(element, '_unblockEditors');
        const e = createEvent();
        element._dragEnd(e);
        assert.isTrue(spy.called);
      });
    });

    suite('_dragoverHandler()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        element._reorderDragover = () => {};
        element._newTabDragover = () => {};
        flush(() => done());
      });

      function dispatch(element, types) {
        if (!types) {
          types = ['arc/request-object'];
        }
        const e = new Event('dragover', {cancelable: true});
        e.dataTransfer = new MockedDataTransfer();
        types.forEach((type) => {
          e.dataTransfer.setData(type, 'test');
        });
        const node = element.shadowRoot.querySelector('.tabs');
        node.dispatchEvent(e);
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dragoverHandler();
        // no error
      });

      test('Ignores event when supported type is not set', () => {
        const spy = sinon.spy(element, '_newTabDragover');
        dispatch(element, ['other']);
        assert.isFalse(spy.called);
      });

      test('Handles the event when arc/request-object', () => {
        const spy = sinon.spy(element, '_newTabDragover');
        dispatch(element);
        assert.isTrue(spy.called);
      });

      test('Handles the event when arc/project-object', () => {
        const spy = sinon.spy(element, '_newTabDragover');
        dispatch(element, ['arc/project-object']);
        assert.isTrue(spy.called);
      });

      test('Cancels the event', () => {
        const e = dispatch(element);
        assert.isTrue(e.defaultPrevented);
      });

      test('Sets dropEffect for new tab', () => {
        const e = dispatch(element);
        assert.equal(e.dataTransfer.dropEffect, 'copy');
      });

      test('Sets dropEffect for reorder', () => {
        const e = dispatch(element, ['arc/request-object', 'arc-source/requests-workspace']);
        assert.equal(e.dataTransfer.dropEffect, 'move');
      });

      test('Calls _reorderDragover()', () => {
        const spy = sinon.spy(element, '_reorderDragover');
        dispatch(element, ['arc/request-object', 'arc-source/requests-workspace']);
        assert.isTrue(spy.called);
      });
    });

    suite('_dragleaveHandler()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        flush(() => done());
      });

      function dispatch(element, types) {
        if (!types) {
          types = ['arc/request-object'];
        }
        const e = new Event('dragleave', {cancelable: true});
        e.dataTransfer = new MockedDataTransfer();
        types.forEach((type) => {
          e.dataTransfer.setData(type, 'test');
        });
        const node = element.shadowRoot.querySelector('.tabs');
        node.dispatchEvent(e);
        return e;
      }

      test('Ignores event when draggableEnabled is not set', () => {
        element.draggableEnabled = false;
        element._dragleaveHandler();
        // no error
      });

      test('Ignores event when supported type is not set', () => {
        const e = dispatch(element, ['other']);
        assert.isFalse(e.defaultPrevented);
      });

      test('Handles the event when arc/request-object', () => {
        const e = dispatch(element);
        assert.isTrue(e.defaultPrevented);
      });

      test('Handles the event when arc/project-object', () => {
        const e = dispatch(element, ['arc/project-object']);
        assert.isTrue(e.defaultPrevented);
      });

      test('Calls _removeDropPointer()', () => {
        const spy = sinon.spy(element, '_removeDropPointer');
        dispatch(element);
        assert.isTrue(spy.called);
      });

      test('Clears __dropPointerReference', () => {
        element.__dropPointerReference = 'test';
        dispatch(element);
        assert.isUndefined(element.__dropPointerReference);
      });
    });

    suite('_removeRipples()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
      });

      test('Does nothing when passed element does not have paper-ripple', () => {
        const node = document.createElement('iron-icon');
        document.body.appendChild(node);
        element._removeRipples(node);
        document.body.removeChild(node);
        // no errors, coverage
      });

      test('Removes ripples from a tab', (done) => {
        addRequests(element, 1);
        flush(() => {
          const node = element.shadowRoot.querySelector('.tabs paper-tab');
          MockInteractions.tap(node);
          setTimeout(() => {
            element._removeRipples(node);
            const ripple = node.shadowRoot.querySelector('paper-ripple');
            assert.lengthOf(ripple.ripples, 0);
            done();
          });
        });
      });
    });

    suite('_finishReorder()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
        element._removeRipples = () => {};
        element._rearrangeReorder = () => {};
        element._resetReorderChildren = () => {};
        element._resetReorderState = () => {};
        element._resetReorderStyles = () => {};
      });

      function createEvent() {
        const e = new Event('dragend');
        e.dataTransfer = new MockedDataTransfer();
        return e;
      }

      test('Calls _removeRipples() with an argument', () => {
        const node = document.createElement('div');
        element.__reorderInfo.dragElement = node;
        const spy = sinon.spy(element, '_removeRipples');
        const e = createEvent();
        element._finishReorder(e);
        assert.isTrue(spy.args[0][0] === node);
      });

      test('Calls _rearrangeReorder()', () => {
        const spy = sinon.spy(element, '_rearrangeReorder');
        const e = createEvent();
        element._finishReorder(e);
        assert.isTrue(spy.called);
      });

      test('Calls _resetReorderChildren()', () => {
        const spy = sinon.spy(element, '_resetReorderChildren');
        const e = createEvent();
        element._finishReorder(e);
        assert.isTrue(spy.called);
      });

      test('Calls _resetReorderState()', () => {
        const spy = sinon.spy(element, '_resetReorderState');
        const e = createEvent();
        element._finishReorder(e);
        assert.isTrue(spy.called);
      });

      test('Calls _resetReorderStyles() with an argument', () => {
        const spy = sinon.spy(element, '_resetReorderStyles');
        const e = createEvent();
        element._finishReorder(e);
        assert.isTrue(spy.args[0][0] === e);
      });

      test('Skips selection when no movement', () => {
        const e = createEvent();
        element._finishReorder(e);
        assert.isUndefined(element.selected);
      });

      test('Sets selection when _rearrangeReorder() returns a value', () => {
        element._rearrangeReorder = () => 2;
        const e = createEvent();
        element._finishReorder(e);
        assert.equal(element.selected, 2);
      });

      test('Sets selection when _rearrangeReorder() returns 0', () => {
        element._rearrangeReorder = () => 0;
        const e = createEvent();
        element._finishReorder(e);
        assert.equal(element.selected, 0);
      });
    });

    suite('_rearrangeReorder()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
      });

      test('Returns undefined when no dragIndex', () => {
        const result = element._rearrangeReorder();
        assert.isUndefined(result);
      });

      test('Returns undefined when no overIndex', () => {
        element.__reorderInfo.dragIndex = 1;
        const result = element._rearrangeReorder();
        assert.isUndefined(result);
      });

      test('Rearranges the array', () => {
        element.activeRequests = DataGenerator.generateRequests({
          requestsSize: 3
        });
        const id1 = element.activeRequests[0]._id;
        const id2 = element.activeRequests[1]._id;
        const id3 = element.activeRequests[2]._id;
        element.__reorderInfo.dragIndex = 2;
        element.__reorderInfo.overIndex = 0;
        element._rearrangeReorder();
        assert.equal(element.activeRequests[0]._id, id3);
        assert.equal(element.activeRequests[1]._id, id1);
        assert.equal(element.activeRequests[2]._id, id2);
      });

      test('Returns insert position', () => {
        element.activeRequests = DataGenerator.generateRequests({
          requestsSize: 3
        });
        element.__reorderInfo.dragIndex = 2;
        element.__reorderInfo.overIndex = 1;
        const result = element._rearrangeReorder();
        assert.equal(result, 1);
      });
    });

    suite('_resetReorderStyles()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        element.__tabsSelectionColor = 'red';
        element.__tabsSelectionColor2 = 'yellow';
        flush(() => done());
      });

      function createEvent() {
        const e = {
          currentTarget: document.createElement('div')
        };
        return e;
      }

      test('Sets current target visibility', () => {
        const e = createEvent();
        element._resetReorderStyles(e);
        assert.equal(e.currentTarget.style.visibility, 'visible');
      });

      test('Resets --paper-tabs-selection-bar-color variable', () => {
        const e = createEvent();
        element._resetReorderStyles(e);
        const style = getComputedStyle(element.$.tabs);
        const result = style.getPropertyValue('--paper-tabs-selection-bar-color').trim();
        assert.equal(result, 'red');
      });

      test('Resets --paper-tabs-selection-bar_-_border-color variable', () => {
        const e = createEvent();
        element._resetReorderStyles(e);
        const style = getComputedStyle(element.$.tabs);
        const result = style.getPropertyValue('--paper-tabs-selection-bar_-_border-color').trim();
        assert.equal(result, 'yellow');
      });
    });

    suite('_resetReorderChildren()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 1);
        flush(() => done());
      });

      test('Removes "transform" style', () => {
        const node = element.$.tabs.querySelector('paper-tab');
        node.style.transform = 'translate3d(100px, 0px, 0px)';
        element._resetReorderChildren();
        assert.equal(node.style.transform, '');
      });

      test('Removes "moving" class', () => {
        const node = element.$.tabs.querySelector('paper-tab');
        node.classList.add('moving');
        element._resetReorderChildren();
        assert.isFalse(node.classList.contains('moving'));
      });
    });

    suite('_dropRequest()', () => {
      let element;
      let request;
      setup(function() {
        element = fixture('Draggable');
        element.clearWorkspace = () => {};
        element.appendRequest = () => {};
        element.appendRequestAt = () => {};
        element._computeDropOrder = () => 2;
        request = {
          _id: 'test-id'
        };
      });

      function createEvent() {
        const e = new Event('dragend');
        e.dataTransfer = new MockedDataTransfer();
        e.dataTransfer.setData('arc/request-object', JSON.stringify(request));
        e.ctrlKey = false;
        e.metaKey = false;
        return e;
      }

      test('Calls appendRequestAt() with arguments', () => {
        const e = createEvent();
        const spy = sinon.spy(element, 'appendRequestAt');
        element._dropRequest(e);
        // this implies calling `_computeDropOrder`
        assert.equal(spy.args[0][0], 2);
        assert.deepEqual(spy.args[0][1], request);
      });

      test('Calls clearWorkspace() with ctrl key', () => {
        const e = createEvent();
        e.ctrlKey = true;
        const spy = sinon.spy(element, 'clearWorkspace');
        element._dropRequest(e);
        assert.isTrue(spy.args[0][0]);
      });

      test('Calls appendRequest() with ctrl key', () => {
        const e = createEvent();
        e.ctrlKey = true;
        const spy = sinon.spy(element, 'appendRequest');
        element._dropRequest(e);
        assert.deepEqual(spy.args[0][0], request);
      });
    });

    suite('_dropProject()', () => {
      let element;
      let project;
      setup(function() {
        element = fixture('Draggable');
        element.clearWorkspace = () => {};
        element.appendByProject = () => {};
        element._computeDropOrder = () => 3;
        project = {
          _id: 'test-id'
        };
      });

      function createEvent() {
        const e = new Event('dragend');
        e.dataTransfer = new MockedDataTransfer();
        e.dataTransfer.setData('arc/project-object', JSON.stringify(project));
        e.ctrlKey = false;
        e.metaKey = false;
        return e;
      }

      test('Calls appendByProject() with arguments', () => {
        const e = createEvent();
        const spy = sinon.spy(element, 'appendByProject');
        element._dropProject(e);
        // this implies calling `_computeDropOrder`
        assert.deepEqual(spy.args[0][0], project);
        assert.equal(spy.args[0][1], 3);
      });

      test('Calls clearWorkspace() with ctrl key', () => {
        const e = createEvent();
        e.ctrlKey = true;
        const spy = sinon.spy(element, 'clearWorkspace');
        element._dropProject(e);
        assert.isTrue(spy.args[0][0]);
      });

      test('Calls appendByProject() with ctrl key', () => {
        const e = createEvent();
        e.ctrlKey = true;
        const spy = sinon.spy(element, 'appendByProject');
        element._dropProject(e);
        assert.deepEqual(spy.args[0][0], project);
        assert.isUndefined(spy.args[0][1]);
      });
    });

    suite('_computeDropOrder()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 1);
        flush(() => done());
      });

      test('Returns requests size when no pointer reference', () => {
        const result = element._computeDropOrder();
        assert.equal(result, 1);
      });

      test('Returns requests size when reference is dom-repeat', () => {
        const node = element.shadowRoot.querySelector('dom-repeat');
        element.__dropPointerReference = node;
        const result = element._computeDropOrder();
        assert.equal(result, 1);
      });

      test('Returns reference item position', () => {
        const node = element.shadowRoot.querySelector('.tabs paper-tab');
        element.__dropPointerReference = node;
        const result = element._computeDropOrder();
        assert.equal(result, 0);
      });
    });

    suite('_blockEditors()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 1);
        flush(() => done());
      });

      test('Sets readonly on the editors', () => {
        element._blockEditors();
        const node = element.shadowRoot.querySelector('request-panel');
        assert.isTrue(node.readonly);
      });
    });

    suite('_unblockEditors()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 1);
        flush(() => done());
      });

      test('Reets readonly on the editors', (done) => {
        const node = element.shadowRoot.querySelector('request-panel');
        node.readonly = true;
        element._unblockEditors();
        afterNextRender(element, () => {
          assert.isFalse(node.readonly);
          done();
        });
      });
    });

    suite('_createDropPointer()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 2);
        flush(() => done());
      });

      test('Adds pointer to the DOM', () => {
        const node = element.shadowRoot.querySelector('.tabs paper-tab');
        element._createDropPointer(node);
        const pointer = element.shadowRoot.querySelector('.drop-pointer');
        assert.ok(pointer);
      });

      test('Pointer has left position', () => {
        const node = element.shadowRoot.querySelector('.tabs paper-tab');
        element._createDropPointer(node);
        const pointer = element.shadowRoot.querySelector('.drop-pointer');
        assert.equal(pointer.style.left, '46px');
      });

      test('Adds pointer when ref is dom-repeat', () => {
        const node = element.shadowRoot.querySelector('dom-repeat');
        element._createDropPointer(node);
        const pointer = element.shadowRoot.querySelector('.drop-pointer');
        assert.typeOf(pointer.style.left, 'string');
        assert.notEqual(pointer.style.left, '46px');
      });
    });

    suite('_removeDropPointer()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
      });

      test('Does nothing when __dropPointer not set', () => {
        element._removeDropPointer();
        // no error
      });

      test('Removes pointer from the DOM', () => {
        const elm = document.createElement('div');
        elm.id = 'test-elm';
        element.shadowRoot.appendChild(elm);
        element.__dropPointer = elm;
        element._removeDropPointer();
        const node = element.shadowRoot.querySelector('#test-elm');
        assert.equal(node, null);
      });
    });

    suite('_dropHandler()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
        element._dropRequest = () => {};
        element._dropProject = () => {};
      });

      function createEvent(type) {
        const e = {
          dataTransfer: new MockedDataTransfer(),
          defaultPrevented: false,
          preventDefault: () => {
            e.defaultPrevented = true;
          }
        };
        if (type) {
          e.dataTransfer.setData(type, 'test');
        }
        return e;
      }

      test('Does nothing when draggableEnabled not set', () => {
        element.draggableEnabled = false;
        const e = createEvent('arc/request-object');
        element._dropHandler(e);
        assert.isFalse(e.defaultPrevented);
      });

      test('Does nothing when reorder mode', () => {
        element.__reorderInfo.type = 'track';
        const e = createEvent('arc/request-object');
        element._dropHandler(e);
        assert.isFalse(e.defaultPrevented);
      });

      test('Does nothing when unsupported type', () => {
        element.__reorderInfo.type = 'track';
        const e = createEvent('arc/test');
        element._dropHandler(e);
        assert.isFalse(e.defaultPrevented);
      });

      test('Cancels the event', () => {
        const e = createEvent('arc/request-object');
        element._dropHandler(e);
        assert.isTrue(e.defaultPrevented);
      });
    });

    suite('_getReorderDdx()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
        element.__reorderInfo.moves.push({x: 1, y: 2});
      });

      test('Returns 0 when no second move', () => {
        const result = element._getReorderDdx();
        assert.equal(result, 0);
      });

      test('Returns difference between last and previous moves', () => {
        element.__reorderInfo.moves.push({x: 3, y: 4});
        const result = element._getReorderDdx();
        assert.equal(result, 2);
      });
    });

    suite('_updateReorderMoves()', () => {
      let element;
      setup(function() {
        element = fixture('Draggable');
      });

      test('Adds x and y position from the event', () => {
        element._updateReorderMoves({
          clientX: 1,
          clientY: 2
        });
        assert.lengthOf(element.__reorderInfo.moves, 1);
        const move = element.__reorderInfo.moves[0];
        assert.deepEqual(move, {x: 1, y: 2});
      });
    });

    suite('_updateChildrenReorder()', () => {
      let element;
      setup(function(done) {
        element = fixture('Draggable');
        addRequests(element, 3);
        flush(() => done());
      });

      test('Adds moving class on children except for dragged item', () => {
        element._updateChildrenReorder(0, 2, 1, 0);
        const children = element.$.tabs.querySelectorAll('paper-tab');
        assert.isTrue(children[0].classList.contains('moving'));
        assert.isFalse(children[1].classList.contains('moving'));
        assert.isTrue(children[2].classList.contains('moving'));
      });

      test('Adds transform style on children except for dragged item', () => {
        element._updateChildrenReorder(0, 2, 1, 0);
        const children = element.$.tabs.querySelectorAll('paper-tab');
        assert.notEqual(children[0].style.transform.indexOf('translate3d'), -1);
        assert.equal(children[1].style.transform.indexOf('translate3d'), -1);
        assert.notEqual(children[2].style.transform.indexOf('translate3d'), -1);
      });
    });
  });
  </script>
</body>
</html>
