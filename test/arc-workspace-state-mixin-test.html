<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>ArcWorkspaceStateMixin test</title>

  <script src="../../../@webcomponents/webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../../@polymer/test-fixture/test-fixture.js"></script>
  <script src="../../../mocha/mocha.js"></script>
  <script src="../../../chai/chai.js"></script>
  <script src="../../../wct-mocha/wct-mocha.js"></script>

  <!-- CodeMirror + modes loader -->
  <script src="../../../codemirror/lib/codemirror.js"></script>
  <script src="../../../codemirror/addon/mode/loadmode.js"></script>
  <script src="../../../codemirror/mode/meta.js"></script>
  <!--Default set of parsers, add as many as you need -->
  <script src="../../../codemirror/mode/javascript/javascript.js"></script>
  <script src="../../../codemirror/mode/xml/xml.js"></script>
  <script src="../../../codemirror/mode/htmlmixed/htmlmixed.js"></script>
  <!-- JSON linter -->
  <script src="../../../jsonlint/lib/jsonlint.js"></script>
  <script src="../../../codemirror/addon/lint/lint.js"></script>
  <script src="../../../codemirror/addon/lint/json-lint.js"></script>
  <!-- Headers hint support -->
  <script src="../../../@advanced-rest-client/code-mirror-hint/headers-addon.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/show-hint.js"></script>
  <script src="../../../@advanced-rest-client/code-mirror-hint/hint-http-headers.js"></script>
</head>
<body>
  <project-model></project-model>
  <request-model></request-model>
  <variables-model></variables-model>

  <test-fixture id="Basic">
    <template>
      <arc-request-workspace no-auto-projects no-auto-restore></arc-request-workspace>
    </template>
  </test-fixture>

  <script type="module">
  import {DataGenerator} from '../../arc-data-generator/arc-data-generator.js';
  import {afterNextRender} from '../../../@polymer/polymer/lib/utils/render-status.js';
  import '../../arc-models/project-model.js';
  import '../../arc-models/request-model.js';
  import '../../arc-models/variables-model.js';
  import '../arc-request-workspace.js';
  import sinon from '../../../sinon/pkg/sinon-esm.js';

  suite('ArcWorkspaceStateMixin', () => {
    suite('_dispatchWorkspaceState()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Dispatches workspace-state-read event', () => {
        const spy = sinon.spy();
        element.addEventListener('workspace-state-read', spy);
        element._dispatchWorkspaceState();
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element._dispatchWorkspaceState();
        assert.typeOf(e, 'customevent');
      });

      test('Event has type on detail', () => {
        const e = element._dispatchWorkspaceState();
        assert.equal(e.detail.type, 'workspace-state');
      });
    });

    suite('_restoreModelError()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns rejected promise', () => {
        const result = element._restoreModelError();
        assert.typeOf(result.then, 'function');
        return result.then(() => {
          throw new Error('Should not result.');
        })
        .catch((cause) => {
          assert.equal(cause.message, '"workspace-state-read" event for workspace state not handled');
        });
      });

      test('Calls addEmptyRequest()', () => {
        const spy = sinon.spy(element, 'addEmptyRequest');
        return element._restoreModelError()
        .catch(() => {})
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Sets restoring flag to false', () => {
        element._setRestoring(true);
        return element._restoreModelError()
        .catch(() => {})
        .then(() => {
          assert.isFalse(element.restoring);
        });
      });

      test('Sets initialized flag to true', () => {
        element._setInitialized(false);
        return element._restoreModelError()
        .catch(() => {})
        .then(() => {
          assert.isTrue(element.initialized);
        });
      });
    });

    suite('_restoreMeta()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Sets version', () => {
        const version = '0.1.0';
        element._restoreMeta({version});
        assert.equal(element.version, version);
      });

      test('Sets published', () => {
        const published = '2019-04-20T17:56:36.726Z';
        element._restoreMeta({published});
        assert.equal(element.published, published);
      });

      test('Sets provider.url', () => {
        const provider = {url: 'https://domain.com'};
        element._restoreMeta({provider});
        assert.equal(element.provider.url, provider.url);
      });

      test('Sets provider.name', () => {
        const provider = {name: 'First Last'};
        element._restoreMeta({provider});
        assert.equal(element.provider.name, provider.name);
      });

      test('Sets provider.email', () => {
        const provider = {email: 'test@domain.com'};
        element._restoreMeta({provider});
        assert.equal(element.provider.email, provider.email);
      });
    });

    suite('_restoreRequests()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls addEmptyRequest() when no requests', () => {
        const spy = sinon.spy(element, 'addEmptyRequest');
        element._restoreRequests();
        assert.isTrue(spy.called);
      });

      test('Calls addEmptyRequest() when requests array empty', () => {
        const spy = sinon.spy(element, 'addEmptyRequest');
        element._restoreRequests([]);
        assert.isTrue(spy.called);
      });

      test('Calls refreshTabs() when not requests', () => {
        const spy = sinon.spy(element, 'refreshTabs');
        element._restoreRequests();
        assert.isTrue(spy.called);
      });

      test('Calls appendRequest() for each request in the array', () => {
        const requests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        const spy = sinon.spy(element, 'appendRequest');
        element._restoreRequests(requests);
        assert.equal(spy.callCount, 2);
      });

      test('Calls refreshTabs() when adding requests', () => {
        const requests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        const spy = sinon.spy(element, 'refreshTabs');
        element._restoreRequests(requests);
        assert.isTrue(spy.called);
      });

      test('Generates _id when missing', () => {
        const requests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        requests.forEach((i) => {
          delete i._id;
        });
        element._restoreRequests(requests);
        requests.forEach((i) => {
          assert.typeOf(i._id, 'string');
        });
      });
    });

    suite('_restoreSelected()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Set selection to passed number', () => {
        element._restoreSelected(2);
        assert.equal(element.selected, 2);
      });

      test('Set selection to passed number when argument is a string', () => {
        element._restoreSelected('2');
        assert.equal(element.selected, 2);
      });

      test('Selects latest request when argument is not a number', () => {
        element.activeRequests = [{}, {}];
        element._restoreSelected();
        assert.equal(element.selected, 1);
      });
    });

    suite('_restoreEnvironment()', () => {
      let element;
      const env = 'not-default';
      setup(() => {
        element = fixture('Basic');
      });

      test('Set environment property', () => {
        element._restoreEnvironment(env);
        assert.equal(element.environment, env);
      });

      test('Calls _dispatch() with arguments', () => {
        const spy = sinon.spy(element, '_dispatch');
        element._restoreEnvironment(env);
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'selected-environment-changed', 'Event type is set');
        assert.equal(spy.args[0][1].value, env, 'detail.value is set');
      });

      test('Does nothing when environment is not set', () => {
        element._restoreEnvironment();
        assert.isUndefined(element.environment);
      });
    });

    suite('_restoreVariables()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Set variables property', () => {
        const vars = [{variable: 'test'}];
        element._restoreVariables(vars);
        assert.deepEqual(element.variables, vars);
      });

      test('Does nothing when variables is not set', () => {
        element._restoreVariables();
        assert.isUndefined(element.variables);
      });
    });

    suite('_restoreConfiguration()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Does nothing when variables is not set', () => {
        element._restoreConfiguration();
        assert.isUndefined(element.requestTimeout);
        assert.isUndefined(element.validateCertificates);
        assert.isUndefined(element.followRedirects);
        assert.isUndefined(element.sentMessageLimit);
      });

      test('Set requestTimeout property', () => {
        const config = {requestTimeout: 20};
        element._restoreConfiguration(config);
        assert.equal(element.requestTimeout, 20);
      });

      test('Set requestTimeout property when value is string', () => {
        const config = {requestTimeout: '20'};
        element._restoreConfiguration(config);
        assert.equal(element.requestTimeout, 20);
      });

      test('Set sentMessageLimit property', () => {
        const config = {sentMessageLimit: 20};
        element._restoreConfiguration(config);
        assert.equal(element.sentMessageLimit, 20);
      });

      test('Set sentMessageLimit property when value is string', () => {
        const config = {sentMessageLimit: '20'};
        element._restoreConfiguration(config);
        assert.equal(element.sentMessageLimit, 20);
      });

      [
        'validateCertificates', 'followRedirects', 'workspaceReadOnly',
        'variablesDisabled', 'nativeTransport'
      ]
      .forEach((prop) => {
        test(`Set ${prop} when true`, () => {
          const config = {};
          config[prop] = true;
          element._restoreConfiguration(config);
          assert.isTrue(element[prop]);
        });

        test(`Set ${prop} when false`, () => {
          const config = {};
          config[prop] = false;
          element._restoreConfiguration(config);
          assert.isFalse(element[prop]);
        });
      });
    });

    suite('_restoreWebSessionConfiguration()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Does nothing when values are not set', () => {
        element._restoreWebSessionConfiguration();
        assert.isUndefined(element.webSessionUrl);
      });

      test('Set webSessionUrl property', () => {
        const config = {webSessionUrl: 'https://'};
        element._restoreWebSessionConfiguration(config);
        assert.equal(element.webSessionUrl, 'https://');
      });

      test('Ignores unknown type for webSessionUrl', () => {
        const config = {webSessionUrl: true};
        element._restoreWebSessionConfiguration(config);
        assert.isUndefined(element.webSessionUrl);
      });
    });

    suite('_restoreAuthConfiguration()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Does nothing when values are not set', () => {
        element._restoreAuthConfiguration();
        assert.isUndefined(element._workspaceOauth2RedirectUri);
      });

      test('Set webSessionUrl property', () => {
        const config = {oauth2RedirectUri: 'https://'};
        element._restoreAuthConfiguration(config);
        assert.equal(element._workspaceOauth2RedirectUri, 'https://');
      });

      test('Ignores unknown type for webSessionUrl', () => {
        const config = {oauth2RedirectUri: true};
        element._restoreAuthConfiguration(config);
        assert.isUndefined(element._workspaceOauth2RedirectUri);
      });
    });

    suite('_afterRestore()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Forces selection change', (done) => {
        element.selected = 1;
        const spy = sinon.spy();
        element.addEventListener('selected-changed', spy);
        element._afterRestore();
        afterNextRender(element, () => {
          assert.equal(spy.callCount, 2);
          done();
        });
      });

      test('Sets restoring flag to false', (done) => {
        element._setRestoring(true);
        element._afterRestore();
        afterNextRender(element, () => {
          assert.isFalse(element.restoring);
          done();
        });
      });

      test('Sets initialized flag to true', (done) => {
        element._setInitialized(false);
        element._afterRestore();
        afterNextRender(element, () => {
          assert.isTrue(element.initialized);
          done();
        });
      });
    });

    suite('_restore()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls addEmptyRequest() when no state', () => {
        const spy = sinon.spy(element, 'addEmptyRequest');
        element._restore();
        assert.isTrue(spy.called);
      });

      test('Won\'t call _restoreRequests() when no state', () => {
        const spy = sinon.spy(element, '_restoreRequests');
        element._restore();
        assert.isFalse(spy.called);
      });

      test('Calls _restoreRequests()', () => {
        const spy = sinon.spy(element, '_restoreRequests');
        const requests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        element._restore({
          requests
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], requests);
      });

      test('Calls _restoreMeta()', () => {
        const spy = sinon.spy(element, '_restoreMeta');
        const cnf = {
          version: '0.0.1'
        };
        element._restore(cnf);
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], cnf);
      });

      test('Calls _restoreSelected()', () => {
        const spy = sinon.spy(element, '_restoreSelected');
        element._restore({
          selected: 1
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 1);
      });

      test('Calls _restoreEnvironment()', () => {
        const env = 'other-env';
        const spy = sinon.spy(element, '_restoreEnvironment');
        element._restore({
          environment: env
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], env);
      });

      test('Calls _restoreVariables()', () => {
        const vars = [{variable: 'test'}];
        const spy = sinon.spy(element, '_restoreVariables');
        element._restore({
          variables: vars
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], vars);
      });

      test('Calls _restoreConfiguration()', () => {
        const config = {followRedirects: true};
        const spy = sinon.spy(element, '_restoreConfiguration');
        element._restore({
          config
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], config);
      });

      test('Calls _restoreWebSessionConfiguration()', () => {
        const webSession = {webSessionUrl: 'https://'};
        const spy = sinon.spy(element, '_restoreWebSessionConfiguration');
        element._restore({
          webSession
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], webSession);
      });

      test('Calls _restoreAuthConfiguration()', () => {
        const auth = {oauth2RedirectUri: 'https://'};
        const spy = sinon.spy(element, '_restoreAuthConfiguration');
        element._restore({
          auth
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], auth);
      });
    });

    suite('restoreWorkspace()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      function dataFactory(e) {
        e.preventDefault();
        e.detail.result = new Promise((resolve) => {
          const requests = DataGenerator.generateRequests({
            requestsSize: 2
          });

          resolve({
            requests,
            selected: 1,
            environment: 'other-env'
          });
        });
      }

      function noopFactory(e) {
        e.preventDefault();
        e.detail.result = Promise.resolve({});
      }

      function errorFactory(e) {
        e.preventDefault();
        e.detail.result = Promise.reject(new Error('test'));
      }

      test('Clears activeRequests when set', (done) => {
        element.activeRequests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        element.addEventListener('workspace-state-read', noopFactory);
        element.restoreWorkspace();
        element.removeEventListener('workspace-state-read', noopFactory);
        assert.deepEqual(element.activeRequests, []);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Sets restoring to true', (done) => {
        element.addEventListener('workspace-state-read', noopFactory);
        element.restoreWorkspace();
        element.removeEventListener('workspace-state-read', noopFactory);
        assert.isTrue(element.restoring);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Calls _dispatchWorkspaceState()', (done) => {
        const spy = sinon.spy(element, '_dispatchWorkspaceState');
        element.addEventListener('workspace-state-read', noopFactory);
        element.restoreWorkspace();
        element.removeEventListener('workspace-state-read', noopFactory);
        assert.isTrue(spy.called);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Calls _restoreModelError() when no model', (done) => {
        const spy = sinon.spy(element, '_restoreModelError');
        element.restoreWorkspace()
        .catch(() => {});
        assert.isTrue(spy.called);
        afterNextRender(element, () => {
          done();
        });
      });

      test('Restores defaults when no state', (done) => {
        element.addEventListener('workspace-state-read', noopFactory);
        element.restoreWorkspace()
        .then(() => {
          afterNextRender(element, () => {
            assert.lengthOf(element.activeRequests, 1);
            assert.equal(element.selected, 0);
            assert.isUndefined(element.environment);
            done();
          });
        });
        element.removeEventListener('workspace-state-read', noopFactory);
      });

      test('Restores state', (done) => {
        element.addEventListener('workspace-state-read', dataFactory);
        element.restoreWorkspace()
        .then(() => {
          afterNextRender(element, () => {
            assert.lengthOf(element.activeRequests, 2);
            assert.equal(element.selected, 1);
            assert.equal(element.environment, 'other-env');
            done();
          });
        });
        element.removeEventListener('workspace-state-read', dataFactory);
      });

      test('Handles restoration errors', (done) => {
        element.addEventListener('workspace-state-read', errorFactory);
        element.restoreWorkspace()
        .then(() => {
          afterNextRender(element, () => {
            assert.lengthOf(element.activeRequests, 1);
            assert.equal(element.selected, 0);
            assert.isUndefined(element.environment);
            done();
          });
        });
        element.removeEventListener('workspace-state-read', errorFactory);
      });
    });

    suite('serializeConfig()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns object', () => {
        const result = element.serializeConfig();
        assert.typeOf(result, 'object');
      });

      test('Sets requestTimeout when a number', () => {
        element.requestTimeout = 20;
        const result = element.serializeConfig();
        assert.equal(result.requestTimeout, 20);
      });

      test('Skips requestTimeout when not a number', () => {
        element.requestTimeout = 'test';
        const result = element.serializeConfig();
        assert.isUndefined(result.requestTimeout);
      });

      test('Sets sentMessageLimit when a number', () => {
        element.sentMessageLimit = 20;
        const result = element.serializeConfig();
        assert.equal(result.sentMessageLimit, 20);
      });

      test('Skips sentMessageLimit when not a number', () => {
        element.sentMessageLimit = 'test';
        const result = element.serializeConfig();
        assert.isUndefined(result.sentMessageLimit);
      });

      [
        'followRedirects', 'validateCertificates', 'workspaceReadOnly',
        'variablesDisabled', 'nativeTransport'
      ].forEach((prop) => {
        test(`Sets ${prop} when false`, () => {
          element[prop] = false;
          const result = element.serializeConfig();
          assert.isFalse(result[prop]);
        });

        test(`Sets ${prop} when true`, () => {
          element[prop] = true;
          const result = element.serializeConfig();
          assert.isTrue(result[prop]);
        });

        test(`Skips ${prop} when not a boolean`, () => {
          element[prop] = 'test';
          const result = element.serializeConfig();
          assert.isUndefined(result.validateCertificates);
        });
      });
    });

    suite('serializeWebSession()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns object', () => {
        const result = element.serializeWebSession();
        assert.typeOf(result, 'object');
      });

      test('Sets webSessionUrl when a string', () => {
        element.webSessionUrl = 'https://';
        const result = element.serializeWebSession();
        assert.equal(result.webSessionUrl, 'https://');
      });

      test('Skips webSessionUrl when not a string', () => {
        element.webSessionUrl = true;
        const result = element.serializeWebSession();
        assert.isUndefined(result.webSessionUrl);
      });
    });

    suite('serializeAuthorization()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns object', () => {
        const result = element.serializeAuthorization();
        assert.typeOf(result, 'object');
      });

      test('Sets oauth2RedirectUri when a string', () => {
        element._workspaceOauth2RedirectUri = 'https://';
        const result = element.serializeAuthorization();
        assert.equal(result.oauth2RedirectUri, 'https://');
      });

      test('Skips oauth2RedirectUri when not a string', () => {
        element._workspaceOauth2RedirectUri = true;
        const result = element.serializeAuthorization();
        assert.isUndefined(result.oauth2RedirectUri);
      });
    });

    suite('serializeWorkspace()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns object', () => {
        const result = element.serializeWorkspace();
        assert.typeOf(result, 'object');
      });

      test('Sets default environment', () => {
        const result = element.serializeWorkspace();
        assert.equal(result.environment, 'default');
      });

      test('Sets default selected', () => {
        const result = element.serializeWorkspace();
        assert.equal(result.selected, 0);
      });

      test('Sets default requests', () => {
        const old = element.activeRequests;
        element.activeRequests = undefined;
        const result = element.serializeWorkspace();
        element.activeRequests = old;
        assert.deepEqual(result.requests, []);
      });

      test('Sets environment', () => {
        element.environment = 'other-env';
        const result = element.serializeWorkspace();
        assert.equal(result.environment, 'other-env');
      });

      test('Sets default selected', () => {
        element.selected = 3;
        const result = element.serializeWorkspace();
        assert.equal(result.selected, 3);
      });

      test('Sets requests', () => {
        element.activeRequests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        const result = element.serializeWorkspace();
        assert.deepEqual(result.requests, element.activeRequests);
      });

      test('Calls serializeConfig()', () => {
        const spy = sinon.spy(element, 'serializeConfig');
        element.serializeWorkspace();
        assert.isTrue(spy.called);
      });

      test('Sets config', () => {
        element.followRedirects = true;
        const result = element.serializeWorkspace();
        assert.deepEqual(result.config, {followRedirects: true});
      });

      test('Sets variables', () => {
        const vars = [{variable: 'test'}];
        element.variables = vars;
        const result = element.serializeWorkspace();
        assert.deepEqual(result.variables, vars);
      });

      test('Calls serializeWebSession()', () => {
        const spy = sinon.spy(element, 'serializeWebSession');
        element.serializeWorkspace();
        assert.isTrue(spy.called);
      });

      test('Calls serializeAuthorization()', () => {
        const spy = sinon.spy(element, 'serializeAuthorization');
        element.serializeWorkspace();
        assert.isTrue(spy.called);
      });

      test('Sets webSession', () => {
        element.webSessionUrl = 'https://';
        const result = element.serializeWorkspace();
        assert.deepEqual(result.webSession, {webSessionUrl: 'https://'});
      });
    });

    suite('__dispatchStoreWorkspace()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls serializeWorkspace()', () => {
        const spy = sinon.spy(element, 'serializeWorkspace');
        element.__dispatchStoreWorkspace();
        assert.isTrue(spy.called);
      });

      test('Clears __storingTimeout', () => {
        element.__storingTimeout = 1234;
        element.__dispatchStoreWorkspace();
        assert.isUndefined(element.__storingTimeout);
      });

      test('Calls _dispatch() with arguments', () => {
        const spy = sinon.spy(element, '_dispatch');
        element.__dispatchStoreWorkspace();
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'workspace-state-store', 'Event type is set');
        const compare = element.serializeWorkspace();
        assert.deepEqual(spy.args[0][1].value, compare, 'Detail is set');
      });

      test('Dispatches workspace-state-store event', () => {
        let detail;
        element.addEventListener('workspace-state-store', function f(e) {
          element.removeEventListener('workspace-state-store', f);
          e.preventDefault();
          detail = e.detail;
        });
        element.__dispatchStoreWorkspace();
        assert.typeOf(detail, 'object');
        const compare = element.serializeWorkspace();
        assert.deepEqual(detail.value, compare, 'Detail is set');
      });
    });

    suite('_notifyStoreWorkspace()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
        element._setInitialized(true);
      });

      test('Does nothing when not initialized', () => {
        element._setInitialized(false);
        const spy = sinon.spy(element, 'serializeWorkspace');
        element._notifyStoreWorkspace();
        assert.isFalse(spy.called);
      });

      test('Does nothing when restoring', () => {
        element._setRestoring(true);
        const spy = sinon.spy(element, 'serializeWorkspace');
        element._notifyStoreWorkspace();
        assert.isFalse(spy.called);
      });

      test('Does nothing when workspaceReadOnly', () => {
        element.workspaceReadOnly = true;
        const spy = sinon.spy(element, 'serializeWorkspace');
        element._notifyStoreWorkspace();
        assert.isFalse(spy.called);
      });

      test('Will not call _clearStoreTimeout() when __storingTimeout is not set', () => {
        const spy = sinon.spy(element, '_clearStoreTimeout');
        element._notifyStoreWorkspace();
        assert.isFalse(spy.called);
      });

      test('Calls _clearStoreTimeout() when __storingTimeout is set', () => {
        element.__storingTimeout = 123;
        const spy = sinon.spy(element, '_clearStoreTimeout');
        element._notifyStoreWorkspace();
        assert.isTrue(spy.called);
      });

      test('Sets __storingTimeout property', () => {
        element._notifyStoreWorkspace();
        assert.typeOf(element.__storingTimeout, 'number');
      });

      test('Ewentually calls __dispatchStoreWorkspace()', (done) => {
        element._notifyStoreWorkspace();
        const spy = sinon.spy(element, '__dispatchStoreWorkspace');
        setTimeout(() => {
          assert.isTrue(spy.called);
          done();
        }, 1000);
      });

      test('Uses requestAnimationFrame() as fallback', (done) => {
        const old = window.requestIdleCallback;
        window.requestIdleCallback = undefined;
        const spy = sinon.spy(window, 'requestAnimationFrame');
        element._notifyStoreWorkspace();
        setTimeout(() => {
          window.requestIdleCallback = old;
          assert.isTrue(spy.called);
          done();
        });
      });
    });

    suite('_clearStoreTimeout()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls cancelIdleCallback()', () => {
        if (!window.cancelIdleCallback) {
          return;
        }
        const spy = sinon.spy(window, 'cancelIdleCallback');
        element.__storingTimeout = 123;
        element._clearStoreTimeout();
        window.cancelIdleCallback.restore();
        assert.isTrue(spy.called);
      });

      test('Uses cancelAnimationFrame() as fallback', () => {
        const old = window.cancelIdleCallback;
        window.cancelIdleCallback = undefined;
        const spy = sinon.spy(window, 'cancelAnimationFrame');
        element.__storingTimeout = 123;
        element._clearStoreTimeout();
        window.cancelIdleCallback = old;
        window.cancelAnimationFrame.restore();
        assert.isTrue(spy.called);
      });

      test('Clears __storingTimeout', () => {
        element.__storingTimeout = 123;
        element._clearStoreTimeout();
        assert.isUndefined(element.__storingTimeout);
      });
    });

    suite('_workspaceConfigChanged()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls _notifyStoreWorkspace()', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element._workspaceConfigChanged();
        assert.isTrue(spy.called);
      });

      test('Won\'t call _notifyStoreWorkspace() when restoring', () => {
        element._setRestoring(true);
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element._workspaceConfigChanged();
        assert.isFalse(spy.called);
      });

      test('Called when "environment" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.environment = 'test';
        assert.isTrue(spy.called);
      });

      test('Called when "requestTimeout" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.requestTimeout = 100;
        assert.isTrue(spy.called);
      });

      test('Called when "validateCertificates" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.validateCertificates = true;
        assert.isTrue(spy.called);
      });

      test('Called when "followRedirects" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.followRedirects = true;
        assert.isTrue(spy.called);
      });

      test('Called when "sentMessageLimit" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.sentMessageLimit = 100;
        assert.isTrue(spy.called);
      });

      test('Called when "webSessionUrl" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.webSessionUrl = 'https://';
        assert.isTrue(spy.called);
      });
    });

    suite('_workspaceReadOnlyChanged()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls __dispatchStoreWorkspace()', () => {
        const spy = sinon.spy(element, '__dispatchStoreWorkspace');
        element._workspaceReadOnlyChanged();
        assert.isTrue(spy.called);
      });

      test('Called when "workspaceReadOnly" changes', () => {
        const spy = sinon.spy(element, '__dispatchStoreWorkspace');
        element.workspaceReadOnly = false;
        assert.isTrue(spy.called);
      });
    });
  });
  </script>
</body>
</html>
