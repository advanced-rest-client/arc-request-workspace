<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
  <title>ArcWorkspaceStateMixin test</title>
  <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
  <script src="../../web-component-tester/browser.js"></script>
  <link rel="import" href="../arc-request-workspace.html">
  <link rel="import" href="../../arc-data-generator/arc-data-generator.html">
  <link rel="import" href="../../arc-models/project-model.html">
  <link rel="import" href="../../arc-models/request-model.html">
  <link rel="import" href="../../arc-models/variables-model.html">
</head>
<body>
  <project-model></project-model>
  <request-model></request-model>
  <variables-model></variables-model>

  <test-fixture id="Basic">
    <template>
      <arc-request-workspace no-auto-projects no-auto-restore></arc-request-workspace>
    </template>
  </test-fixture>

  <script>
  /* global DataGenerator */
  suite('ArcWorkspaceStateMixin', () => {
    suite('_dispatchWorkspaceState()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Dispatches workspace-state-read event', () => {
        const spy = sinon.spy();
        element.addEventListener('workspace-state-read', spy);
        element._dispatchWorkspaceState();
        assert.isTrue(spy.called);
      });

      test('Returns the event', () => {
        const e = element._dispatchWorkspaceState();
        assert.typeOf(e, 'customevent');
      });

      test('Event has type on detail', () => {
        const e = element._dispatchWorkspaceState();
        assert.equal(e.detail.type, 'workspace-state');
      });
    });

    suite('_restoreModelError()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns rejected promise', () => {
        const result = element._restoreModelError();
        assert.typeOf(result.then, 'function');
        return result.then(() => {
          throw new Error('Should not result.');
        })
        .catch((cause) => {
          assert.equal(cause.message, '"workspace-state-read" event for workspace state not handled');
        });
      });

      test('Calls addEmptyRequest()', () => {
        const spy = sinon.spy(element, 'addEmptyRequest');
        return element._restoreModelError()
        .catch(() => {})
        .then(() => {
          assert.isTrue(spy.called);
        });
      });

      test('Sets restoring flag to false', () => {
        element._setRestoring(true);
        return element._restoreModelError()
        .catch(() => {})
        .then(() => {
          assert.isFalse(element.restoring);
        });
      });

      test('Sets initialized flag to true', () => {
        element._setInitialized(false);
        return element._restoreModelError()
        .catch(() => {})
        .then(() => {
          assert.isTrue(element.initialized);
        });
      });
    });

    suite('_restoreRequests()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls addEmptyRequest() when no requests', () => {
        const spy = sinon.spy(element, 'addEmptyRequest');
        element._restoreRequests();
        assert.isTrue(spy.called);
      });

      test('Calls addEmptyRequest() when requests array empty', () => {
        const spy = sinon.spy(element, 'addEmptyRequest');
        element._restoreRequests([]);
        assert.isTrue(spy.called);
      });

      test('Calls refreshTabs() when not requests', () => {
        const spy = sinon.spy(element, 'refreshTabs');
        element._restoreRequests();
        assert.isTrue(spy.called);
      });

      test('Calls appendRequest() for each request in the array', () => {
        const requests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        const spy = sinon.spy(element, 'appendRequest');
        element._restoreRequests(requests);
        assert.equal(spy.callCount, 2);
      });

      test('Calls refreshTabs() when adding requests', () => {
        const requests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        const spy = sinon.spy(element, 'refreshTabs');
        element._restoreRequests(requests);
        assert.isTrue(spy.called);
      });

      test('Generates _id when missing', () => {
        const requests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        requests.forEach((i) => {
          delete i._id;
        });
        element._restoreRequests(requests);
        requests.forEach((i) => {
          assert.typeOf(i._id, 'string');
        });
      });
    });

    suite('_restoreSelected()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Set selection to passed number', () => {
        element._restoreSelected(2);
        assert.equal(element.selected, 2);
      });

      test('Set selection to passed number when argument is a string', () => {
        element._restoreSelected('2');
        assert.equal(element.selected, 2);
      });

      test('Selects latest request when argument is not a number', () => {
        element.activeRequests = [{}, {}];
        element._restoreSelected();
        assert.equal(element.selected, 1);
      });
    });

    suite('_restoreEnvironment()', () => {
      let element;
      const env = 'not-default';
      setup(() => {
        element = fixture('Basic');
      });

      test('Set environment property', () => {
        element._restoreEnvironment(env);
        assert.equal(element.environment, env);
      });

      test('Calls _dispatch() with arguments', () => {
        const spy = sinon.spy(element, '_dispatch');
        element._restoreEnvironment(env);
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'selected-environment-changed', 'Event type is set');
        assert.equal(spy.args[0][1].value, env, 'detail.value is set');
      });

      test('Does nothing when environment is not set', () => {
        element._restoreEnvironment();
        assert.isUndefined(element.environment);
      });
    });

    suite('_restoreVariables()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Set variables property', () => {
        const vars = [{variable: 'test'}];
        element._restoreVariables(vars);
        assert.deepEqual(element.variables, vars);
      });

      test('Does nothing when variables is not set', () => {
        element._restoreVariables();
        assert.isUndefined(element.variables);
      });
    });

    suite('_restoreConfiguration()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Does nothing when variables is not set', () => {
        element._restoreConfiguration();
        assert.isUndefined(element.requestTimeout);
        assert.isUndefined(element.validateCertificates);
        assert.isUndefined(element.followRedirects);
        assert.isUndefined(element.sentMessageLimit);
      });

      test('Set requestTimeout property', () => {
        const config = {requestTimeout: 20};
        element._restoreConfiguration(config);
        assert.equal(element.requestTimeout, 20);
      });

      test('Set requestTimeout property when value is string', () => {
        const config = {requestTimeout: '20'};
        element._restoreConfiguration(config);
        assert.equal(element.requestTimeout, 20);
      });

      test('Set validateCertificates when true', () => {
        const config = {validateCertificates: true};
        element._restoreConfiguration(config);
        assert.isTrue(element.validateCertificates);
      });

      test('Set validateCertificates when false', () => {
        const config = {validateCertificates: false};
        element._restoreConfiguration(config);
        assert.isFalse(element.validateCertificates);
      });

      test('Set followRedirects when true', () => {
        const config = {followRedirects: true};
        element._restoreConfiguration(config);
        assert.isTrue(element.followRedirects);
      });

      test('Set followRedirects when false', () => {
        const config = {followRedirects: false};
        element._restoreConfiguration(config);
        assert.isFalse(element.followRedirects);
      });

      test('Set sentMessageLimit property', () => {
        const config = {sentMessageLimit: 20};
        element._restoreConfiguration(config);
        assert.equal(element.sentMessageLimit, 20);
      });

      test('Set sentMessageLimit property when value is string', () => {
        const config = {sentMessageLimit: '20'};
        element._restoreConfiguration(config);
        assert.equal(element.sentMessageLimit, 20);
      });
    });

    suite('_afterRestore()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Forces selection change', (done) => {
        element.selected = 1;
        const spy = sinon.spy();
        element.addEventListener('selected-changed', spy);
        element._afterRestore();
        Polymer.RenderStatus.afterNextRender(element, () => {
          assert.equal(spy.callCount, 2);
          done();
        });
      });

      test('Sets restoring flag to false', (done) => {
        element._setRestoring(true);
        element._afterRestore();
        Polymer.RenderStatus.afterNextRender(element, () => {
          assert.isFalse(element.restoring);
          done();
        });
      });

      test('Sets initialized flag to true', (done) => {
        element._setInitialized(false);
        element._afterRestore();
        Polymer.RenderStatus.afterNextRender(element, () => {
          assert.isTrue(element.initialized);
          done();
        });
      });
    });

    suite('_restore()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls addEmptyRequest() when no state', () => {
        const spy = sinon.spy(element, 'addEmptyRequest');
        element._restore();
        assert.isTrue(spy.called);
      });

      test('Won\'t call _restoreRequests() when no state', () => {
        const spy = sinon.spy(element, '_restoreRequests');
        element._restore();
        assert.isFalse(spy.called);
      });

      test('Calls _restoreRequests()', () => {
        const spy = sinon.spy(element, '_restoreRequests');
        const requests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        element._restore({
          requests
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], requests);
      });

      test('Calls _restoreSelected()', () => {
        const spy = sinon.spy(element, '_restoreSelected');
        element._restore({
          selected: 1
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 1);
      });

      test('Calls _restoreEnvironment()', () => {
        const env = 'other-env';
        const spy = sinon.spy(element, '_restoreEnvironment');
        element._restore({
          environment: env
        });
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], env);
      });

      test('Calls _restoreVariables()', () => {
        const vars = [{variable: 'test'}];
        const spy = sinon.spy(element, '_restoreVariables');
        element._restore({
          variables: vars
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], vars);
      });

      test('Calls _restoreConfiguration()', () => {
        const config = {followRedirects: true};
        const spy = sinon.spy(element, '_restoreConfiguration');
        element._restore({
          config
        });
        assert.isTrue(spy.called);
        assert.deepEqual(spy.args[0][0], config);
      });
    });

    suite('restoreWorkspace()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      function dataFactory(e) {
        e.preventDefault();
        e.detail.result = new Promise((resolve) => {
          const requests = DataGenerator.generateRequests({
            requestsSize: 2
          });

          resolve({
            requests,
            selected: 1,
            environment: 'other-env'
          });
        });
      }

      function noopFactory(e) {
        e.preventDefault();
        e.detail.result = Promise.resolve({});
      }

      function errorFactory(e) {
        e.preventDefault();
        e.detail.result = Promise.reject(new Error('test'));
      }

      test('Clears activeRequests when set', (done) => {
        element.activeRequests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        element.addEventListener('workspace-state-read', noopFactory);
        element.restoreWorkspace();
        element.removeEventListener('workspace-state-read', noopFactory);
        assert.deepEqual(element.activeRequests, []);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Sets restoring to true', (done) => {
        element.addEventListener('workspace-state-read', noopFactory);
        element.restoreWorkspace();
        element.removeEventListener('workspace-state-read', noopFactory);
        assert.isTrue(element.restoring);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Calls _dispatchWorkspaceState()', (done) => {
        const spy = sinon.spy(element, '_dispatchWorkspaceState');
        element.addEventListener('workspace-state-read', noopFactory);
        element.restoreWorkspace();
        element.removeEventListener('workspace-state-read', noopFactory);
        assert.isTrue(spy.called);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Calls _restoreModelError() when no model', (done) => {
        const spy = sinon.spy(element, '_restoreModelError');
        element.restoreWorkspace()
        .catch(() => {});
        assert.isTrue(spy.called);
        Polymer.RenderStatus.afterNextRender(element, () => {
          done();
        });
      });

      test('Restores defaults when no state', (done) => {
        element.addEventListener('workspace-state-read', noopFactory);
        element.restoreWorkspace()
        .then(() => {
          Polymer.RenderStatus.afterNextRender(element, () => {
            assert.lengthOf(element.activeRequests, 1);
            assert.equal(element.selected, 0);
            assert.isUndefined(element.environment);
            done();
          });
        });
        element.removeEventListener('workspace-state-read', noopFactory);
      });

      test('Restores state', (done) => {
        element.addEventListener('workspace-state-read', dataFactory);
        element.restoreWorkspace()
        .then(() => {
          Polymer.RenderStatus.afterNextRender(element, () => {
            assert.lengthOf(element.activeRequests, 2);
            assert.equal(element.selected, 1);
            assert.equal(element.environment, 'other-env');
            done();
          });
        });
        element.removeEventListener('workspace-state-read', dataFactory);
      });

      test('Handles restoration errors', (done) => {
        element.addEventListener('workspace-state-read', errorFactory);
        element.restoreWorkspace()
        .then(() => {
          Polymer.RenderStatus.afterNextRender(element, () => {
            assert.lengthOf(element.activeRequests, 1);
            assert.equal(element.selected, 0);
            assert.isUndefined(element.environment);
            done();
          });
        });
        element.removeEventListener('workspace-state-read', errorFactory);
      });
    });

    suite('serializeConfig()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns object', () => {
        const result = element.serializeConfig();
        assert.typeOf(result, 'object');
      });

      test('Sets requestTimeout when a number', () => {
        element.requestTimeout = 20;
        const result = element.serializeConfig();
        assert.equal(result.requestTimeout, 20);
      });

      test('Skips requestTimeout when not a number', () => {
        element.requestTimeout = 'test';
        const result = element.serializeConfig();
        assert.isUndefined(result.requestTimeout);
      });

      test('Sets sentMessageLimit when a number', () => {
        element.sentMessageLimit = 20;
        const result = element.serializeConfig();
        assert.equal(result.sentMessageLimit, 20);
      });

      test('Skips sentMessageLimit when not a number', () => {
        element.sentMessageLimit = 'test';
        const result = element.serializeConfig();
        assert.isUndefined(result.sentMessageLimit);
      });

      test('Sets validateCertificates when a boolean', () => {
        element.validateCertificates = false;
        const result = element.serializeConfig();
        assert.isFalse(result.validateCertificates);
      });

      test('Skips validateCertificates when not a boolean', () => {
        element.validateCertificates = 'test';
        const result = element.serializeConfig();
        assert.isUndefined(result.validateCertificates);
      });

      test('Sets followRedirects when a boolean', () => {
        element.followRedirects = false;
        const result = element.serializeConfig();
        assert.isFalse(result.followRedirects);
      });

      test('Skips followRedirects when not a boolean', () => {
        element.followRedirects = 'test';
        const result = element.serializeConfig();
        assert.isUndefined(result.followRedirects);
      });
    });

    suite('serializeWorkspace()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Returns object', () => {
        const result = element.serializeWorkspace();
        assert.typeOf(result, 'object');
      });

      test('Sets default environment', () => {
        const result = element.serializeWorkspace();
        assert.equal(result.environment, 'default');
      });

      test('Sets default selected', () => {
        const result = element.serializeWorkspace();
        assert.equal(result.selected, 0);
      });

      test('Sets default requests', () => {
        const old = element.activeRequests;
        element.activeRequests = undefined;
        const result = element.serializeWorkspace();
        element.activeRequests = old;
        assert.deepEqual(result.requests, []);
      });

      test('Sets environment', () => {
        element.environment = 'other-env';
        const result = element.serializeWorkspace();
        assert.equal(result.environment, 'other-env');
      });

      test('Sets default selected', () => {
        element.selected = 3;
        const result = element.serializeWorkspace();
        assert.equal(result.selected, 3);
      });

      test('Sets requests', () => {
        element.activeRequests = DataGenerator.generateRequests({
          requestsSize: 2
        });
        const result = element.serializeWorkspace();
        assert.deepEqual(result.requests, element.activeRequests);
      });

      test('Calls serializeConfig()', () => {
        const spy = sinon.spy(element, 'serializeConfig');
        element.serializeWorkspace();
        assert.isTrue(spy.called);
      });

      test('Sets config', () => {
        element.followRedirects = true;
        const result = element.serializeWorkspace();
        assert.deepEqual(result.config, {followRedirects: true});
      });

      test('Sets variables', () => {
        const vars = [{variable: 'test'}];
        element.variables = vars;
        const result = element.serializeWorkspace();
        assert.deepEqual(result.variables, vars);
      });
    });

    suite('__dispatchStoreWorkspace()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls serializeWorkspace()', () => {
        const spy = sinon.spy(element, 'serializeWorkspace');
        element.__dispatchStoreWorkspace();
        assert.isTrue(spy.called);
      });

      test('Clears __storingTimeout', () => {
        element.__storingTimeout = 1234;
        element.__dispatchStoreWorkspace();
        assert.isUndefined(element.__storingTimeout);
      });

      test('Calls _dispatch() with arguments', () => {
        const spy = sinon.spy(element, '_dispatch');
        element.__dispatchStoreWorkspace();
        assert.isTrue(spy.called);
        assert.equal(spy.args[0][0], 'workspace-state-store', 'Event type is set');
        const compare = element.serializeWorkspace();
        assert.deepEqual(spy.args[0][1].value, compare, 'Detail is set');
      });

      test('Dispatches workspace-state-store event', () => {
        let detail;
        element.addEventListener('workspace-state-store', function f(e) {
          element.removeEventListener('workspace-state-store', f);
          e.preventDefault();
          detail = e.detail;
        });
        element.__dispatchStoreWorkspace();
        assert.typeOf(detail, 'object');
        const compare = element.serializeWorkspace();
        assert.deepEqual(detail.value, compare, 'Detail is set');
      });
    });

    suite('_notifyStoreWorkspace()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
        element._setInitialized(true);
      });

      test('Does nothing when not initialized', () => {
        element._setInitialized(false);
        const spy = sinon.spy(element, 'serializeWorkspace');
        element._notifyStoreWorkspace();
        assert.isFalse(spy.called);
      });

      test('Does nothing when restoring', () => {
        element._setRestoring(true);
        const spy = sinon.spy(element, 'serializeWorkspace');
        element._notifyStoreWorkspace();
        assert.isFalse(spy.called);
      });

      test('Will not call _clearStoreTimeout() when __storingTimeout is not set', () => {
        const spy = sinon.spy(element, '_clearStoreTimeout');
        element._notifyStoreWorkspace();
        assert.isFalse(spy.called);
      });

      test('Calls _clearStoreTimeout() when __storingTimeout is set', () => {
        element.__storingTimeout = 123;
        const spy = sinon.spy(element, '_clearStoreTimeout');
        element._notifyStoreWorkspace();
        assert.isTrue(spy.called);
      });

      test('Sets __storingTimeout property', () => {
        element._notifyStoreWorkspace();
        assert.typeOf(element.__storingTimeout, 'number');
      });

      test('Ewentually calls __dispatchStoreWorkspace()', (done) => {
        element._notifyStoreWorkspace();
        const spy = sinon.spy(element, '__dispatchStoreWorkspace');
        setTimeout(() => {
          assert.isTrue(spy.called);
          done();
        }, 1000);
      });

      test('Uses requestAnimationFrame() as fallback', (done) => {
        const old = window.requestIdleCallback;
        window.requestIdleCallback = undefined;
        const spy = sinon.spy(window, 'requestAnimationFrame');
        element._notifyStoreWorkspace();
        setTimeout(() => {
          window.requestIdleCallback = old;
          assert.isTrue(spy.called);
          done();
        });
      });
    });

    suite('_clearStoreTimeout()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls cancelIdleCallback()', () => {
        if (!window.cancelIdleCallback) {
          return;
        }
        const spy = sinon.spy(window, 'cancelIdleCallback');
        element.__storingTimeout = 123;
        element._clearStoreTimeout();
        window.cancelIdleCallback.restore();
        assert.isTrue(spy.called);
      });

      test('Uses cancelAnimationFrame() as fallback', () => {
        const old = window.cancelIdleCallback;
        window.cancelIdleCallback = undefined;
        const spy = sinon.spy(window, 'cancelAnimationFrame');
        element.__storingTimeout = 123;
        element._clearStoreTimeout();
        window.cancelIdleCallback = old;
        window.cancelAnimationFrame.restore();
        assert.isTrue(spy.called);
      });

      test('Clears __storingTimeout', () => {
        element.__storingTimeout = 123;
        element._clearStoreTimeout();
        assert.isUndefined(element.__storingTimeout);
      });
    });

    suite('_workspaceConfigChanged()', () => {
      let element;
      setup(() => {
        element = fixture('Basic');
      });

      test('Calls _notifyStoreWorkspace()', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element._workspaceConfigChanged();
        assert.isTrue(spy.called);
      });

      test('Won\'t call _notifyStoreWorkspace() when restoring', () => {
        element._setRestoring(true);
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element._workspaceConfigChanged();
        assert.isFalse(spy.called);
      });

      test('Called when "environment" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.environment = 'test';
        assert.isTrue(spy.called);
      });

      test('Called when "requestTimeout" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.requestTimeout = 100;
        assert.isTrue(spy.called);
      });

      test('Called when "validateCertificates" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.validateCertificates = true;
        assert.isTrue(spy.called);
      });

      test('Called when "followRedirects" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.followRedirects = true;
        assert.isTrue(spy.called);
      });

      test('Called when "sentMessageLimit" changes', () => {
        const spy = sinon.spy(element, '_notifyStoreWorkspace');
        element.sentMessageLimit = 100;
        assert.isTrue(spy.called);
      });
    });
  });
  </script>
</body>
</html>
